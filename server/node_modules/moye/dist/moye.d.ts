// Generated by dts-bundle-generator v8.0.1

/**
 * 构造函数
 */
export interface Type<T = any> extends Function {
	new (...args: any[]): T;
}
export interface IMessage {
}
export interface IRequest extends IMessage {
	/**
	 * 用于rpc调用的唯一id
	 */
	rpcId: number;
}
export interface IResponse extends IMessage {
	/**
	 * 用于rpc调用的唯一id
	 */
	rpcId: number;
	/**
	 * 错误码 0表示成功
	 */
	error: number;
	/**
	 * 错误信息 一般在error不为0时才有
	 */
	message?: string;
}
export interface IEventSystem {
	registerSystem(component: Entity): void;
	awakeComEvent(component: Entity): void;
	destroyComEvent(component: Entity): void;
}
export interface IRoot {
	add(entity: Entity): void;
	remove(instanceId: number): void;
	get(instanceId: number): Entity;
}
export interface SceneInitArgs {
	id: number;
	instanceId?: number;
	sceneType: string;
	name: string;
	parent?: Entity;
}
export declare class Scene extends Entity {
	name: string;
	sceneType: string;
	set domain(value: Entity);
	get domain(): Entity;
	set parent(value: Entity);
	init(args: SceneInitArgs): void;
}
export declare abstract class Entity {
	static IRoot: IRoot;
	static IEventSystem: IEventSystem;
	get parent(): Entity;
	set parent(value: Entity);
	get domain(): Entity;
	set domain(value: Entity);
	instanceId: number;
	id: number;
	get isDisposed(): boolean;
	get children(): Map<number, Entity>;
	get components(): Map<Type<Entity>, Entity>;
	protected _domain: Entity;
	private _children;
	private _components;
	protected _parent: Entity;
	private status;
	private componentsDB;
	private childrenDB;
	private get isFromPool();
	private set isFromPool(value);
	private get isComponent();
	private set isComponent(value);
	protected get isCreated(): boolean;
	protected set isCreated(value: boolean);
	protected get isNew(): boolean;
	protected set isNew(value: boolean);
	protected get isRegister(): boolean;
	protected set isRegister(value: boolean);
	private set componentParent(value);
	addComponent(component: Entity): Entity;
	addComponent<T extends Entity>(type: Type<T>): T;
	addComponent<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	tryAddComponent<T extends Entity>(type: Type<T>): T;
	private addComponentByEntity;
	private addComponentByCtor;
	addChild(entity: Entity): Entity;
	addChild<T extends Entity>(type: Type<T>): T;
	addChild<T extends Entity>(type: Type<T>, isFromPool: boolean): T;
	addChildWithId<T extends Entity>(type: Type<T>, id: number, isFromPool?: boolean): T;
	private addChildByEntity;
	private addChildByCtor;
	private create;
	private removeFromChildren;
	private removeFromChildrenDB;
	private removeFromComponents;
	private removeFromComponentsDB;
	private addToComponents;
	private AddToComponentsDB;
	private AddToChildrenDB;
	private addToChildren;
	getComponent<K extends Entity>(type: new () => K): K;
	removeComponent<T extends Entity>(type: Type<T>): T;
	getParent<T extends Entity>(type: Type<T>): T;
	getChild<T extends Entity>(type: Type<T>, id: number): T;
	removeChild(id: number): void;
	dispose(): void;
	domainScene(): Scene;
	getType(): Type;
	awake?(): void;
	update?(): void;
	lateUpdate?(): void;
	destroy?(): void;
}
export declare class IPEndPoint {
	host: string;
	port: number;
	constructor(host: string, port?: number);
	toString(): string;
}
export declare class Task<T = any> extends Promise<T> {
	private _resolve;
	/**
	 * 创建一个新的task
	 * @param type
	 * @returns
	 */
	static create<T = any>(type?: Type<T>): Task<T>;
	setResult(result?: T): void;
	/**
	 * 不允许直接new
	 * @param executor
	 */
	private constructor();
	private dispose;
}
export declare class RpcInfo {
	readonly Request: IRequest;
	Tcs: Task<IResponse>;
	constructor(request: IRequest);
	setResult(val: IResponse): void;
}
/**
 * session的id跟channel的id是一样的
 */
export declare class Session extends Entity {
	static RpcId: number;
	ServiceId: number;
	requestCallbacks: Map<number, RpcInfo>;
	LastRecvTime: number;
	LastSendTime: number;
	Error: number;
	RemoteAddress: IPEndPoint;
	init(serviceId: number): void;
	OnResponse(response: IResponse): void;
	Send(message: IMessage): void;
	SendWithId(actorId: number, message: IMessage): void;
	Call(request: IRequest): Promise<IResponse>;
	destroy(): void;
}
/**
 * 消息处理器的接口 所有的消息处理器都要实现这个接口
 */
export interface IMHandler {
	handle(session: Session, message: IMessage, responseType: Type<IMessage>): void;
}
/**
 * 客户端只需要用这一个消息处理器
 * 直接接收到的消息 且不需要回复
 */
export declare abstract class AMHandler<A extends IMessage> implements IMHandler {
	/**
	 * 请不要用异步 因为异步的话可能没办法保证消息的顺序
	 * @param session
	 * @param message
	 */
	protected abstract run(session: Session, message: A): void;
	handle(session: Session, msg: A): void;
}
/**
 * 单例基类
 */
export declare class Singleton {
	private static _inst;
	private _isDisposed;
	static getInst<T extends Singleton>(this: new () => T): T;
	get isDisposed(): boolean;
	/**
	 * 添加后立即调用
	 */
	awake?(): void;
	/**
	 * 每帧调用
	 */
	update?(): void;
	lateUpdate?(): void;
	/**
	* 组件销毁调用
	*/
	onDestroy?(): void;
	dispose(): void;
	_onPreDestroy(): void;
}
export declare class ObjectPool extends Singleton {
	private _pool;
	fetch<T>(type: Type<T>): T;
	recycle(obj: object): void;
}
export interface ILifecycle {
	isDisposed: boolean;
	/**
	 * 添加后立即调用
	 */
	awake?(): void;
	/**
	 * 每帧调用
	 */
	update?(): void;
	lateUpdate?(): void;
	_onPreDestroy(): void;
}
export declare class Game {
	private static readonly singletonMap;
	private static readonly singletons;
	private static readonly destroys;
	private static readonly updates;
	private static readonly lateUpdates;
	private static frameFinishTaskQueue;
	static addSingleton<T extends ILifecycle>(singletonCtor: new () => T): T;
	static waitFrameFinish(): Promise<void>;
	static update(): void;
	static lateUpdate(): void;
	static frameFinishUpdate(): void;
	static dispose(): void;
}
export declare class Root extends Singleton {
	get scene(): Scene;
	private _scene;
	private readonly allEntities;
	awake(): void;
	destroy(): void;
	add(entity: Entity): void;
	remove(instanceId: number): void;
	get(instanceId: number): Entity;
}
/**
 * 消息类型管理器
 * 比如通过opcode得到MessageType
 * 或者通过Type得到MessageType
 */
export declare class MessageTypeMgr extends Singleton {
	private _messageTypeMap;
	private _typeToMessageTypeMap;
	awake(): void;
	destroy(): void;
	getMessageType(type: Type<IMessage>): string;
	isResponse(opcode: number): boolean;
}
export declare class MessageDispatcherInfo {
	sceneType: string;
	msgHandler: IMHandler;
	responseType: Type<IResponse>;
	constructor(sceneType: string, msgHandler: IMHandler, responseType: Type<IResponse>);
}
/**
 * 普通消息分发
 * 也就是直接到达的消息
 * 客户端跟服务端都有使用
 */
export declare class MessageDispatcherMgr extends Singleton {
	private _handlers;
	awake(): void;
	destroy(): void;
	private registerHandler;
	private load;
	handle(session: Session, message: IMessage): void;
}
export declare class EntitySceneFactory {
	static createScene(args: SceneInitArgs): Scene;
}
/**
 * 可回收对象
 */
export declare abstract class RecycleObj {
	private _isRecycle;
	/**
	 * 通过对象池创建
	 * @param this
	 * @param values
	 * @returns
	 */
	static create<T extends RecycleObj>(this: Type<T>, values?: Partial<T>): T;
	/**
	 * 如果是通过create方法创建的
	 * 那么dispose会回收到对象池
	 */
	dispose(): void;
}
export declare class AWait extends RecycleObj {
	error: number;
}
export type Action<T = any> = () => T;
/**
 * 用来取消某些异步的东西
 */
export declare class CancellationToken {
	private _actions;
	/**
	 *
	 * @param callback 添加取消动作
	 * @returns
	 */
	add(callback: Action<void>): void;
	remove(callback: Action<void>): void;
	/**
	 * 执行取消动作
	 * @returns
	 */
	cancel(): void;
	isCancel(): boolean;
	private invoke;
}
export declare class ObjectWait extends Entity {
	private tcss;
	/**
	 * 一直等待 知道notify了 永不超时
	 * @param type
	 * @param cancellationToken
	 * @returns
	 */
	wait<T extends AWait>(type: Type<T>, cancellationToken?: CancellationToken): Promise<T>;
	/**
	 * 等待且有超时限制 超时将会取消等待
	 * @param type
	 * @param timeout ms
	 * @param cancellationToken
	 * @returns
	 */
	waitWithTimeout<T extends AWait>(type: Type<T>, timeout: number, cancellationToken?: CancellationToken): Promise<T>;
	/**
	 * 取消上一个等待
	 * @param type
	 */
	private cancelLastWait;
	/**
	 * 超时取消等待
	 * @param type
	 * @param time
	 * @param cancellationToken
	 * @returns
	 */
	private timeoutRun;
	notify<T extends AWait>(obj: T): void;
}
export declare enum WaitError {
	Success = 0,
	Destroy = 1,
	Cancel = 2,
	Timeout = 3
}
export declare class CoroutineLockItem {
	key: string;
	task: Task<void>;
	private _timeoutInfo;
	private _timerId1;
	private _timerId2;
	init(key: string): void;
	/**
	 *
	 * @param timeout 用于开发阶段 多久没解锁就打印警告
	 * @param info
	 * @returns
	 */
	setTimeoutInfo(timeout: number, info: string): void;
	private timeout;
	dispose(): void;
}
export declare class CoroutineLock extends Singleton {
	private lockMap;
	wait(lockType: string, key: string): Promise<CoroutineLockItem>;
	runNextLock(lock: CoroutineLockItem): void;
}
export declare class DecoratorCollector {
	private static _inst;
	static get inst(): DecoratorCollector;
	private decorators;
	add(decoratorType: string, ...args: any[]): void;
	get(decoratorType: string): Array<any>;
}
/**
 * 可通过value获取key的map
 */
export declare class DoubleMap<K, V> {
	private readonly kv;
	private readonly vk;
	iterator(): IterableIterator<K>;
	Add(key: K, value: V): void;
	GetValueByKey(key: K): V;
	GetKeyByValue(value: V): K;
	RemoveByKey(key: K): void;
	Clear(): void;
}
export declare class TimeHelper {
	static readonly OneDay: number;
	static readonly Hour: number;
	static readonly Minute: number;
	static clientNow(): number;
	static clientNowSeconds(): number;
	static dateTimeNow(): Date;
	static serverNow(): number;
	static clientFrameTime(): number;
	static serverFrameTime(): number;
}
export declare class TimeInfo extends Singleton {
	private serverMinusClientTime;
	frameTime: number;
	awake(): void;
	get ServerMinusClientTime(): number;
	set ServerMinusClientTime(value: number);
	update(): void;
	clientNow(): number;
	serverNow(): number;
	clientFrameTime(): number;
	serverFrameTime(): number;
}
export declare class TimerMgr extends Singleton {
	private _timerMap;
	private _timers;
	/**
	 * 不断重复的定时器
	 * @param time ms
	 * @param callback
	 * @returns
	 */
	newRepeatedTimer(time: number, callback: Function): number;
	newOnceTimer(timeout: number, callback: Function): number;
	newFrameTimer(callback: Function): number;
	remove(id: number): boolean;
	/**
	 * 浏览器上会有一个问题
	 * 就是cocos的update后台不执行,但是js脚本依然执行，导致大量的timer没回收
	 * 暂时不处理这个问题 应该没什么影响
	 */
	update(): void;
	/**
	 *
	 * @param time ms
	 * @param cancellationToken
	 * @returns
	 */
	waitAsync(time: number, cancellationToken?: CancellationToken): Promise<void>;
}
/**
 * 数值组件
 */
export declare class NumericComponent extends Entity {
	NumericDic: Map<number, number>;
	add(nt: number, value: number): void;
	addNoEvent(nt: number, value: number): void;
	sub(nt: number, value: number): void;
	subNoEvent(nt: number, value: number): void;
	set(nt: number, value: number, isPublicEvent?: boolean): void;
	setNoEvent(nt: number, value: number): void;
	get(nt: number): number;
	updateKey(numericType: number, isPublicEvent?: boolean): void;
	resetBase(numericType: number): void;
}
/**
 * 事件基类
 */
export declare abstract class AEvent extends RecycleObj {
}
export declare class EntryEvent extends AEvent {
}
export declare class NumericChange extends AEvent {
	entity: Entity;
	numericType: number;
	old: number;
	new: number;
}
export declare class NetErrorEvent extends AEvent {
	channelId: number;
	error: number;
}
export interface INumericWatcherHandler {
	run(unit: Entity, args: NumericChange): void;
}
/**
 * 监听数值变化
 * @param entityType 实体类型
 * @param type 数值类型
 * @returns
 */
export declare function NumericWatcherHandlerDecorator(entityType: Type<Entity>, type: number): (target: Function) => void;
/**
 * 随机数生成器
 */
export declare class RandomGenerator {
	/**
	 * 随机整数 [min, max]
	 * @param min
	 * @param max
	 * @returns
	 */
	static RandomInt(min: number, max: number): number;
	/**
	 * 万分比是否触发
	 * @param prob
	 * @returns
	 */
	static isTrigger10000Prob(prob: number): boolean;
	/**
	 * 百分比是否触发
	 * @param prob
	 * @returns
	 */
	static isTrigger100Prob(prob: number): boolean;
}
/**
 * 消息解析管理类 可以通过opcode获取对应的解析器
 */
export declare class MessageParserMgr extends Singleton {
	parsers: Map<number, Type>;
	awake(): void;
	getParser(opcode: number): any;
}
/**
 * 消息解析器装饰器
 * @param opcode
 * @param messageType
 * @returns
 */
export declare function MessageParserDecorator(opcode: number): (target: Function) => void;
/**
 * 装饰消息
 * @param opcode
 * @param messageType
 * @returns
 */
export declare function MessageDecorator(opcode: number, messageType: string): (target: Function) => void;
export declare enum MessageTypeCore {
	Message = "Message",
	Request = "Request",
	Response = "Response",
	ActorMessage = "ActorMessage",
	ActorRequest = "ActorRequest",
	ActorResponse = "ActorResponse",
	ActorLocationMessage = "ActorLocationMessage",
	ActorLocationRequest = "ActorLocationRequest",
	ActorLocationResponse = "ActorLocationResponse"
}
export declare function ResponseTypeDecorator(responseType: Type<IMessage>): (target: Function) => void;
declare enum AppType {
	/**
	 * 启动指定进程
	 */
	Server = 0,
	/**
	 * 守护进程 用来启动本台机器上的所有进程
	 */
	Watcher = 1,
	/**
	 * 将所有进程合并到一个进程启动
	 * 如果有监听外网的端口 要确保不会冲突
	 */
	AllInOne = 2
}
export declare class Options extends Singleton {
	/**
	 * 是否是服务端
	 */
	isServer: boolean;
	/**
	 * 进程序号
	 */
	process: number;
	/**
	 * 区id
	 */
	zone: number;
	/**
	 * log等级 越低输出信息越多
	 * 不能控制框架层的输出
	 */
	logLevel: number;
	/**
	 * 是否开发阶段
	 * 开发阶段log会输出到控制台
	 * 所以不要在生产环境设置为true
	 */
	develop: boolean;
	/**
	 * 控制台命令行输入
	 */
	console: boolean;
	/**
	 * 启动类型
	 */
	appType: AppType;
	private _argsMap;
	_setArgs(key: string, value: any): void;
	/**
	 * 获取启动参数
	 * key 大小写敏感
	 * @param key
	 * @returns
	 */
	getArgs(key: string): any;
}
export declare class IdGenerator extends Singleton {
	awake(): void;
	generateInstanceId(): number;
	generateId(): number;
}
/**
 * key对应value数组的map
 */
export declare class MultiMap<T, K> {
	private map;
	private readonly Empty;
	constructor();
	add(t: T, k: K): void;
	remove(t: T, k: K): boolean;
	getAll(t: T): K[];
	get(t: T): K[];
	getOne(t: T): K | undefined;
	contains(t: T, k: K): boolean;
}
export declare abstract class AEventHandler<A> {
	protected abstract run(scene: Scene, args: A): any;
	handleAsync(scene: Scene, a: A): Promise<void>;
	handle(scene: Scene, a: A): void;
}
/**
 * 事件装饰器
 * @param eventCls
 * @param sceneType
 * @returns
 */
export declare function EventHandlerDecorator(eventCls: Type<AEvent>, sceneType: string): (target: Function) => void;
export declare abstract class AInvoke {
	static create<T extends AInvoke>(this: Type<T>, values?: Partial<T>): T;
	dispose(): void;
}
export interface ILog {
	log(str: string): void;
	warn(str: string): void;
	error(str: string): void;
}
/**
 * Logger
 */
export declare class Logger extends Singleton {
	private _iLog;
	set iLog(value: ILog);
	private static readonly LOG_LEVEL;
	private static readonly WARN_LEVEL;
	log(str: string, ...args: any[]): void;
	warn(str: string, ...args: any[]): void;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	error(str: string, ...args: any[]): void;
	private checkLogLevel;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreLog;
	/**
	 * 不受logLevel影响的log
	 * @param str
	 * @param args
	 */
	private coreWarn;
	/**
	 * 错误打印会带上堆栈 用于定位错误
	 * 错误打印不会受到logLevel的影响 一定会打印
	 * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
	 * @param str
	 * @param args
	 */
	private coreError;
}
export declare function log(str: string, ...args: any[]): void;
export declare function warn(str: string, ...args: any[]): void;
export declare function error(str: string, ...args: any[]): void;
export declare class JsHelper {
	static getMethodName(): string;
	static getRootDirName(path: string): string;
	static sleep(ms: number): Promise<void>;
	static isNullOrEmpty(str: string): boolean;
	static getStringHashCode(str: string): number;
	static modeString(str: string, mode: number): number;
	/**
	 * 格式化字符串
	 * @param str 包含有 0 个或者多个格式符的字符串
	 * @param args
	 * @returns 格式化后的新字符串
	 * @performance 性能是+号拼接10分之1, 也就是比较慢, 要注意性能
	 * ```
	 * formatStr("hello {0}", "world") => hello world
	 * formatStr("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
	 * formatStr("hello {{qaq}} {0}", "world") => hello {qaq} world
	 * ```
	 */
	static formatStr(str: string, ...args: any[]): string;
}
/**
 * action执行完毕会销毁 所以注意不要在action里面保存任何状态
 */
export interface IFrameFinishAction {
	/**
	 * 初始化
	 */
	awake(): void;
	/**
	 * 回收重置
	 */
	destroy(): void;
	/**
	 * 注意啊 这里千万不能异步的 因为这个是在lateUpdate里面执行的
	 */
	run(): any;
}
/**
 * 帧结束后的动作管理器
 * 比如在帧结束后，执行某些动作
 */
export declare class FrameFinishActionMgr extends Singleton {
	private _actionMap;
	getAction<T extends IFrameFinishAction>(actionType: Type<T>): T;
	lateUpdate(): void;
}
declare class EventItem {
	entity: Entity;
	handler: Function;
	eventCode: number;
}
/**
 * 事件组件 可以发送事件给监听的对象
 * 不允许取消订阅
 */
export declare class EventComponent extends Entity {
	eventMap: Map<number, Set<EventItem>>;
	/**
	 * handler不需要绑定entity 也就是不需要bind
	 * @param eventType
	 * @param handler
	 * @param entity
	 */
	subscribe(eventCode: number, handler: Function, entity: Entity): void;
	publish(eventCode: number, ...args: any[]): void;
}
/**
 * 消息打印器
 */
export declare class MsgPrinter extends Singleton {
	private _ignoreDebugLogMessages;
	/**
	 * 是否需要在收到消息的时候打印
	 */
	private _isLog;
	/**
	 * 是否需要print
	 * 如果为false 那么所有print都不会打印
	 */
	private _isPrint;
	private isNeedLogMessage;
	private replacer;
	/**
	 * 供收到消息的时候调用 可以忽略一些消息的打印
	 * @param message
	 * @returns
	 */
	log(message: IMessage, prefix?: string): void;
	/**
	 * 直接打印出消息
	 * @param message
	 */
	print(message: IMessage, prefix?: string): void;
	/**
	 * 将消息转化成string
	 * @param message
	 * @returns
	 */
	getMsgString(message: IMessage): string;
	ignore(opcode: number): void;
	closePrint(): void;
	closeLog(): void;
}
/**
 * 需要存数据库的类 不需要查询的
 */
export declare function DB(constructor: Function): void;
/**
 * 需要存数据库的类 且需要查询的
 * @param key 查询的字段
 * @param isNumberKey 是否是数字key 如果不是就是字符串key
 * @param maxCache 最大缓存数量,缓存服缓存该对象的最大数量，如果超出了就会从缓存中删除
 * @returns
 */
export declare function DBWithKey(key: string, isNumberKey: boolean, maxCache: number): (target: Function) => void;
/**
 * 需要传送的组件添加这个装饰器
 * 注意 child是不会跟着传送的 只能用于组件上
 * 但是使用DB标志的child和组件都可以跟随传送
 * 不要同时使用Transfer和DB标志
 * 因为包含db的必然会跟着传送
 * @returns
 */
export declare function Transfer(constructor: Function): void;
/**
 * 需要忽略序列化的字段
 * 只能用在类的字段上
 * 原理就是禁止枚举 序列化的时候就不会序列化这个字段
 * @param target
 * @param name
 * @param desc
 * @returns
 */
export declare const IgnoreSerialize: {
	(target: any, name: string): void;
	(target: any, name: string, desc: PropertyDescriptor): PropertyDescriptor;
};
declare class TaskQueue extends RecycleObj {
	id: string;
	private _queue;
	private _running;
	private _expireTime;
	get expireTime(): number;
	get isRunning(): boolean;
	/**
	 * 传入一个方法, 会按顺序执行
	 * @param func
	 * @example add(()=>console.log('hello'))
	 */
	add(func: Action): void;
	/**
	 * 清空所有的任务
	 */
	clear(): void;
	private run;
}
/**
 * 任务队列
 * 可以让异步任务按顺序执行
 */
export declare class TaskQueueMgr extends Singleton {
	private _taskQueueMap;
	awake(): void;
	/**
	 * 通过标识符获取任务队列
	 * 如果不存在则创建一个
	 * @param id
	 * @returns
	 */
	get(id: string): TaskQueue;
	private checkExpire;
}
/**
 * 回调管理器
 */
export declare class InvokeMgr extends Singleton {
	private _invokes;
	awake(): void;
	invoke<A, B>(type: string, args: A): B;
	invokeAsync<A, B>(type: string, args?: A): Promise<B>;
	private getHandler;
}
export declare abstract class AInvokeHandler<A, B> {
	abstract handle(args?: A): B;
}
/**
 * 回调装饰器
 * @param invokeType
 * @returns
 */
export declare function InvokeDecorator(invokeType: string): (target: Function) => void;
export declare class Injector {
	private static _inst;
	static get inst(): Injector;
	private _map;
	addField(type: string, target: any, key: any): void;
	staticField(type: string, inst: any): void;
}
/**
 * 静态字段注入装饰器
 * @param type
 * @returns
 */
export declare function InjectorDecorator(type: string): <T, K extends keyof T>(target: T, key: K) => void;
export interface IProcessCfg {
	id: number;
	/**
	 * 这个进程属于哪一台机器
	 */
	machineId: number;
	/**
	 * 内网通信端口
	 */
	innerPort: number;
}
export interface IProcessInfo extends IProcessCfg {
	/**
	 * 外网ip
	 */
	outerIp: string;
	/**
	 * 内网ip
	 */
	innerIp: string;
	/**
	 * 进程在同一台机器用内网地址通信
	 */
	innerAddress: IPEndPoint;
	/**
	 * 进程在不同机器用外网地址通信
	 */
	outerAddress: IPEndPoint;
}
/**
 * 进程管理器 请在Program.start之前调用init方法初始化
 * 可以用来获取进程的内网地址(注意: 这里的内网地址是指进程间通信的地址, 不是指内网IP)
 * 一开始就需要初始化，因为后面需要用到
 * 比如你的gate是一个进程 map又是一个进程，那么你需要在一开始的时候就把他们的ip地址和端口号写好，这样他们才能互相通信
 */
export declare class ProcessMgr extends Singleton {
	private _processes;
	private _processInfoMap;
	/**
	 * actorid对应的机器id
	 */
	private _actorIdMachineMap;
	private _processIdMachineMap;
	/**
	 * 当前进程所在的机器id
	 */
	private _curMachineId;
	/**
	 * 最多255个进程
	 * @param list 进程信息列表
	 */
	init(cfgs: IProcessCfg[]): void;
	isInit(): boolean;
	/**
	 * 在配置都加载完成后进行一些初始化操作
	 */
	start(): void;
	getProcessInfo(processId: number): IProcessInfo;
	/**
	 * 获取当前进程信息
	 * @returns
	 */
	getCurProcessInfo(): IProcessInfo;
	/**
	 * 获取当前机器的所有进程信息
	 * @returns
	 */
	getThisMachineProcessInfos(): IProcessInfo[];
	/**
	 * 判断某个actorid是否跟当前进程同一机器
	 * @param actorId
	 */
	actorIdIsInMachine(actorId: number): boolean;
	processIdIsInMachine(processId: number): boolean;
}
export interface ISceneCfg {
	id: number;
	name: string;
	sceneType: string;
	/**
	 * 属于哪一个进程
	 */
	processId: number;
	/**
	 * 外网端口
	 * 这个端口是给客户端连接的 不填写则代表不需要对外网开放
	 */
	outerPort?: number;
	/**
	 * 数据库地址
	 * dbCache scene填写
	 * 格式: mongodb://[账号]:[密码]@[ip]:[端口]/[数据库名]
	 * 例如: mongodb://abcjus:sdgfdsds@149.221.52.87:15782/game1
	 */
	dbAddress?: string;
	/**
	 * 数据库名称
	 * dbCache scene填写
	 */
	dbName?: string;
	/**
	 * 数据库缓存间隔
	 */
	dbCacheInterval?: number;
}
export interface ISceneInfo extends ISceneCfg {
	instanceId: number;
	/**
	 * 内网ip
	 */
	innerIp: string;
	/**
	 * 外网ip
	*/
	outerIp: string;
	/**
	 * 外网连接地址
	 */
	outerAddress?: IPEndPoint;
	machineId: number;
}
/**
 * 动态scene自行管理
 * 所有的顶层scene都需要在这里注册 包括不是当前进程的scene
 * 什么是顶层scene呢？就是不会被其他scene包含的scene,比如gate realm
 * 跟ProcessMgr差不多 需要在一开始就注册好
 * scene id是唯一的
 */
export declare class SceneMgr extends Singleton {
	private _scenes;
	private _allSceneInfo;
	private _sceneInfoMap;
	private _processSceneMap;
	private _sceneTypeMap;
	private _sceneNameMap;
	/**
	 * scene配置
	 * @param list
	 */
	init(cfgs: ISceneCfg[]): void;
	isInit(): boolean;
	/**
	 * 在配置都加载完成后进行一些初始化操作
	 */
	start(): void;
	getSceneCfgs(): ISceneCfg[];
	/**
	 * 获取当前进程的所有scene
	 * @returns
	 */
	curProcessScenes(): ISceneInfo[];
	/**
	 * 获取同类型的第一个scene
	 * @param sceneType
	 * @returns
	 */
	getFirstSceneByType(sceneType: string): ISceneInfo;
	/**
	 * 获取同类型的所有scene
	 * @param sceneType
	 * @returns
	 */
	getSceneByType(sceneType: string): ISceneInfo[];
	getSceneById(sceneId: number): ISceneInfo;
	getSceneByName(sceneName: string): ISceneInfo;
}
export interface IChildSceneCfg {
	id: number;
	name: string;
	sceneType: string;
	instanceId?: number;
}
/**
 * scene工厂
 */
export declare class SceneFactory {
	static createByInfo(parent: Entity, info: ISceneInfo): Scene;
	/**
	 * child scene不会注册到scenemgr 需要自己管理
	 * @param parent
	 * @param args
	 */
	static createChildScene(parent: Scene, args: IChildSceneCfg): Scene;
}
/**
 * 代表着玩家的一个实体
 * 也就是一个Unit代表一个客户端
 * 比如玩家登录 进入gate,那么unit就添加在gate上，进入map那么unit就会传送到map上
 */
export declare class Unit extends Entity {
}
export declare class UnitComponent extends Entity {
	get(id: number): Unit;
	remove(id: number): void;
}
/**
 * 内网消息处理器
 * 同一个messageType只能有一个处理器
 * 并不是处理具体的消息 而是处理某一类消息
 * 通过这个处理器再分发到具体的消息处理器
 * @param messageType
 * @returns
 */
export declare function InnerMsgDecorator(messageType: string): (target: Function) => void;
export interface IInnerMessageHandler {
	/**
	 * 要确保不会抛出错误
	 * 哪怕出错了 也会在内处理好
	 * @param actorId
	 * @param msg
	 */
	run(actorId: number, msg: IMessage): void;
}
/**
 * 外网消息处理器
 * 同一个messageType只能有一个处理器
 * 并不是处理具体的消息 而是处理某一类消息
 * 通过这个处理器再分发到具体的消息处理器
 * @param messageType
 * @returns
 */
export declare function OuterMsgDecorator(messageType: string): (target: Function) => void;
export interface IOuterMessageHandler {
	/**
	 * @param session
	 * @param msg
	 * @错误 允许抛出
	 * @异步 不等待
	 */
	run(session: Session, msg: IMessage): void;
}
export declare class ActorMsgHelper {
	/**
	 * 发送actor消息 可以有返回消息
	 * @param actorId 其实就是instanceId
	 * @param request
	 * @param responseType
	 * @returns
	 */
	static call<T>(actorId: number, request: IRequest, responseType?: Type<T>): Promise<T>;
	/**
	 * 发送actor消息 不带返回消息
	 * @param actorId
	 * @param request
	 */
	static send(actorId: number, request: IMessage): void;
}
/**
 * 客户端发给服务端需要回复的消息用这个
 * rpc消息处理器
 * 收到消息后会将回复消息发送回去
 * 优点是不会阻塞 可以在run里面随意await
 */
export declare abstract class AMRpcHandler<TRequest extends IRequest, TResponse extends IResponse> implements IMHandler {
	/**
	 * 必须是异步
	 * 这样可以控制回复的时机
	 * @param session
	 * @param request
	 * @param response
	 */
	protected abstract run(session: Session, request: TRequest, response: TResponse): Promise<any>;
	handle(session: Session, message: TRequest, responseType: Type<TResponse>): void;
	private handleAsync;
}
export declare class R2C_Login implements IResponse {
	address?: string;
	key?: number;
	/**
	 * 用于rpc调用的唯一id
	 */
	rpcId: number;
	/**
	 * 错误码 0表示成功
	 */
	error: number;
	/**
	 * 错误信息 一般在error不为0时才有
	 */
	message?: string;
	constructor(args?: Partial<R2C_Login>);
}
export declare class G2C_LoginGate implements IResponse {
	/**
	 * 用于rpc调用的唯一id
	 */
	rpcId: number;
	/**
	 * 错误码 0表示成功
	 */
	error: number;
	/**
	 * 错误信息 一般在error不为0时才有
	 */
	message?: string;
	constructor(args?: Partial<G2C_LoginGate>);
}
export declare class G2C_Ping implements IResponse {
	time?: number;
	/**
	 * 用于rpc调用的唯一id
	 */
	rpcId: number;
	/**
	 * 错误码 0表示成功
	 */
	error: number;
	/**
	 * 错误信息 一般在error不为0时才有
	 */
	message?: string;
	constructor(args?: Partial<G2C_Ping>);
}
/**
 * 压力测试 收到这个协议的时候自定义操作 例如可以发条消息给map服
 */
export declare class C2G_TestPressure implements IMessage {
	constructor(args?: Partial<C2G_TestPressure>);
}
/**
 * 客户端发消息给Realm服 请求gate地址
 */
export declare class C2R_Login implements IRequest {
	/**
	 * 帐号
	 */
	account: string;
	/**
	 * 密码
	 */
	password: string;
	/**
	 * 用于rpc调用的唯一id
	 */
	rpcId: number;
	constructor(args?: Partial<C2R_Login>);
}
export declare class C2G_LoginGate implements IRequest {
	/**
	 * 登录key 这个要Realm验证通过才有
	 */
	key: number;
	/**
	 * 用于rpc调用的唯一id
	 */
	rpcId: number;
	constructor(args?: Partial<C2G_LoginGate>);
}
export declare class C2G_Ping implements IRequest {
	/**
	 * 用于rpc调用的唯一id
	 */
	rpcId: number;
	constructor(args?: Partial<C2G_Ping>);
}
/**
 * 所有的actor消息处理器都需要实现这个接口
 */
export interface IMActorHandler {
	/**
	 * 这里是异步 可以抛出错误 分发的地方会捕获错误
	 * @param entity
	 * @param fromProcess
	 * @param message
	 * @param responseType
	 */
	handleAsync?(entity: Entity, fromProcess: number, message: IMessage, responseType: Type<IResponse>): Promise<void>;
	handleSync?(entity: Entity, fromProcess: number, message: IMessage, responseType: Type<IResponse>): void;
}
/**
 * 这个一般是服务端不同scene之间的消息处理器
 * 需要回应的actor消息处理器基类
 * 不会阻塞
 */
export declare abstract class AMActorRpcHandler<TRequest extends IRequest, TResponse extends IResponse> implements IMActorHandler {
	/**
	 * 记录rpc消息来自哪个进程
	 * 方便在run方法里面使用
	 */
	protected _fromProcess: number;
	protected abstract run(scene: Scene, request: TRequest, response: TResponse): Promise<any>;
	handleAsync(entity: Scene, fromProcess: number, request: TRequest, responseType: Type<TResponse>): Promise<void>;
}
/**
 * 客户端发送给unit的rpc消息用这个处理器
 * 注意 这个会堵塞消息 尽量不要run里面用await
 * 甚至会阻塞发送端
 */
export declare abstract class AMActorLocationRpcHandler<TRequest extends IRequest, TResponse extends IResponse> implements IMActorHandler {
	protected abstract run(unit: Unit, request: TRequest, response: TResponse): Promise<void>;
	handleAsync(unit: Unit, fromProcess: number, message: TRequest, responseType: Type<TResponse>): Promise<void>;
}
export declare class Program {
	/**
	 * 框架初始化 必须调用
	 */
	static init(): void;
	/**
	 * 确保所有脚本已经加载之后调用start
	 */
	static start(): Promise<void>;
	/**
	 * 启动update定时器
	 */
	private static startTimer;
	private static update;
	private static lateUpdate;
	private static addSingleton;
	private static addRootSceneCom;
}
/**
 * 直发消息处理器装饰器
 * @param msgType
 * @param sceneType
 * @param responseType
 * @returns
 */
export declare function MessageHandlerDecorator(msgType: Type<IMessage>, sceneType: string, responseType?: Type<IMessage>): (msgHandlerType: Function) => void;
export declare enum SceneTypeCore {
	None = "None",
	Process = "Process",
	Realm = "Realm",
	Gate = "Gate",
	Location = "Location",
	DBCache = "DBCache",
	Map = "Map"
}
export declare class DBHelper {
	/**
	 * 就一个缓存服 需要的话可以改成多个
	 * @param key
	 * @returns
	 */
	private static getDB;
	/**
	 * 返回两个参数 一个是错误码 一个是查询结果
	 * @param type
	 * @param key
	 * @returns
	 */
	static query<T>(type: Type<T>, key: string | number): Promise<[
		number,
		T
	]>;
	static save(obj: object): Promise<boolean>;
	static delete<T>(type: Type<T>, key: string | number): Promise<void>;
}
export interface IMachineCfg {
	/**
	 * 机器id
	 */
	id: number;
	/**
	 * 内网IP
	 */
	innerIp: string;
	/**
	 * 外网IP
	 */
	outerIp: string;
}
/**
 * 机器管理
 * 在Program.start()之前注册
 * 比如你需要部署在多台机器 那就需要在这里注册
 */
export declare class MachineMgr extends Singleton {
	private _machines;
	/**
	 * key是machine id
	 */
	private _machineMap;
	init(cfgs: IMachineCfg[]): void;
	isInit(): boolean;
	/**
	 * 在配置都加载完成后进行一些初始化操作
	 */
	start(): void;
	getMachineCfg(machineId: number): IMachineCfg;
}
/**
 * 登录账号密码检测规则
 */
export interface IAccountInspector {
	run(account: string, password: string): number;
}
export declare class LoginMgr extends Singleton {
	private _accountInspector;
	/**
	 * 创建不存在的账号
	 */
	private _createNotExistAccount;
	setAccountInspector(inspector: IAccountInspector): void;
	checkAccount(account: string, password: string): number;
	setCreateNotExistAccount(create: boolean): void;
	getCreateNotExistAccount(): boolean;
}
/**
 * 实现这个接口 可以自定义序列化之前和之后的操作
 */
export interface ISerialize {
	/**
	 * 序列化时调用
	 */
	onSerialize?(): void;
	/**
	 * 反序列化时调用
	 */
	onDeserialize?(): void;
}
/**
 * 玩家数据
 * 每个账号都有一个GatePlayer
 * 用来保存账号的一些信息 比如角色列表等
 */
export declare class GatePlayer extends Entity implements ISerialize {
	private _account;
	get account(): string;
	ref: number;
	init(account: string): this;
	onDeserialize(): void;
	/**
	 * 注意 这里创建是有可能失败的
	 * @param args
	 * @returns 创建是否成功
	 */
	createUnit(args?: any): Promise<boolean>;
}
/**
 * 创建Unit后的事件
 * 可以在这里为Unit添加组件
 */
export declare class AfterCreateUnit extends AEvent {
	unit: Unit;
	args: any;
}
/**
 * 创建GatePlayer后的事件
 * 可以在这里为GatePlayer添加组件
 */
export declare class AfterCreateGatePlayer extends AEvent {
	player: GatePlayer;
}
/**
 * unit传送之后的处理
 * 这个事件不会等待
 */
export declare class AfterUnitTransfer extends AEvent {
	unit: Unit;
}
export declare class SceneCreateEvent extends AEvent {
	sceneInfo: ISceneInfo;
	scene: Scene;
}
/**
 * 只有gate可以收到这个事件
 */
export declare class AfterConnectUnit extends AEvent {
	unitId: number;
	session: Session;
}
/**
 * 只有gate可以收到这个事件
 */
export declare class AfterDisconnectUnit extends AEvent {
	unitId: number;
}
export declare class GatePlayerHelper {
	/**
	 * 通过session获取GatePlayer
	 * @param session
	 * @returns
	 */
	static getGatePlayerFromSession(session: Session): GatePlayer;
	/**
	 * 只有在连接unit成功后才会有unitId
	 * @param session
	 * @returns
	 */
	static getUnitIdFromSession(session: Session): number;
	/**
	 * 给GatePlayer添加引用
	 * @param gatePlayer
	 */
	static addRef(gatePlayer: GatePlayer): void;
	/**
	 * 给GatePlayer减少引用
	 * @param gatePlayer
	 * @returns
	 */
	static subRef(gatePlayer: GatePlayer): void;
	private static tryRemoveGatePlayer;
}
export declare class UnitConnectHelper {
	/**
	 * 连接unit
	 * 如果unit在gatemap返回unit
	 * @param session
	 * @param unitId
	 * @returns
	 */
	static connect(session: Session, unitId: number): Promise<[
		number,
		Unit
	]>;
	/**
	 * 返回所在scene的instanceId
	 * @param session
	 * @param unitId
	 * @returns
	 */
	private static loadFromDB;
	private static getUnitInstanceId;
}
export declare class GateMapHelper {
	static getGateMapInstanceId(session: Session): number;
}
export declare class ActorLocationMsgHelper {
	static call<T extends IResponse>(entityId: number, request: IRequest, responseType: Type<T>): Promise<T>;
	static send(entityId: number, message: IRequest): void;
}
export declare class TransferHelper {
	/**
	 * 弃用
	 * 当unit在gateMap的时候用这个传送
	 * 在Map里面的话就不能用这个了
	 * @param session
	 * @param unitId
	 * @param sceneInstanceId
	 */
	static transfer(unit: Unit, sceneInstanceId: number): Promise<void>;
}
/**
 * actor消息处理器装饰器
 * @param msgType
 * @param sceneType
 * @param responseType
 * @returns
 */
export declare function ActorMessageHandlerDecorator(msgType: Type<IMessage>, sceneType: string, responseType?: Type<IResponse>): (msgHandlerType: Function) => void;
/**
 * 发送给unit的消息 且不用回复的用这个处理器
 * 这个会阻塞后续消息的处理 尽量不要在run里面await耗时操作
 * 如果有耗时操作 可以另外开一个协程
 */
export declare abstract class AMActorLocationHandler<A extends IRequest> implements IMActorHandler {
	protected abstract run(unit: Unit, message: A): void;
	handleSync(entity: Entity, fromProcess: number, message: A, responseType: Type<IResponse>): void;
}
export declare class UnitMsgHelper {
	/**
	 * 发给客户端
	 * @param unit
	 * @param message
	 */
	static sendToClient(unit: Unit, message: IMessage): void;
	/**
	 * 广播消息
	 * @param mapScene
	 * @param message
	 */
	static broadcast(mapScene: Scene, message: IMessage): void;
	/**
	 * 排除某个unitId的广播
	 * @param mapScene
	 * @param message
	 * @param exceptUnitId
	 */
	static broadcastExcept(mapScene: Scene, message: IMessage, exceptUnitId: number): void;
}
export declare class InstanceIdHelper {
	static getSceneInstanceId(processId: number, sceneId: number): number;
	static getProcessId(actorId: number): number;
}
/**
 * 服务端不同进程之间的actor消息处理器
 * 不需要回应的消息用这个处理器
 */
export declare abstract class AMActorHandler<A extends IMessage> implements IMActorHandler {
	protected abstract run(scene: Scene, args: A): void;
	handleSync(entity: Entity, fromProcess: number, message: A, responseType: Type<IResponse>): void;
}
/**
 * unit在map的时候借助这个组件找到对应session
 */
export declare class UnitGateComponent extends Entity {
	gateSessionActorId: number;
	setSessionActorId(id: number): void;
}
export interface ISerializeCfg {
	typeCode: number;
	type: Type;
}
/**
 * 对象序列化
 * 需要用装饰器先注册一下
 * 比如 DB Transfer DBWithKey
 */
export declare class ObjectSerializeMgr extends Singleton {
	typeMap: Map<Type, ISerializeCfg>;
	typeCodeMap: Map<number, ISerializeCfg>;
	private _encoder;
	/**
	 * 同机序列化 也就是你序列化的时候如果数据是发送给本机其它进程的话就会用这个
	 * 可以减少序列化后的大小
	 */
	private _sameMachineEncoder;
	awake(): void;
	serialize(obj: object): Uint8Array;
	serializeSameMachine(obj: object): Uint8Array;
	deserialize(bytes: Uint8Array): any;
	deserializeSameMachine(bytes: Uint8Array): any;
	getTypeCode(type: Type): number;
	getType(typeCode: number): Type;
}

export {};
