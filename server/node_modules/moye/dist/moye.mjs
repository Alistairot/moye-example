import Long from 'long';
import { App, us_listen_socket_close } from 'uWebSockets.js';
import pb$1 from 'protobufjs/light';
import { WebSocket } from 'ws';
import pb from 'protobufjs';
import { addExitCallback } from 'catch-exit';
import { BSON, MongoClient } from 'mongodb';
import { readFileSync, writeFileSync } from 'fs';
import { addExtension, Encoder, decode, encode, isNativeAccelerationEnabled } from 'cbor-x';
import { format, createLogger } from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';
import mri from 'mri';
import { fork } from 'child_process';

// 一些宏定义
/**
 * 是否开发阶段
 * 可以用来控制一些调试信息的输出
 * 以及一些开发中容易出错的地方的检查
 */
const DEVELOP = true;

class JsHelper {
    static getMethodName() {
        let e = new Error();
        let str = e.stack.split("at ")[2];
        let endPos = str.indexOf(" ");
        return str.substring(0, endPos);
    }
    static getRootDirName(path) {
        return path.split("/")[0];
    }
    static sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    static isNullOrEmpty(str) {
        if (str == null) {
            return true;
        }
        if (str.length == 0) {
            return true;
        }
    }
    static getStringHashCode(str) {
        let hash = 5381;
        let i = str.length;
        while (i) {
            hash = (hash * 33) ^ str.charCodeAt(--i);
        }
        return hash >>> 0;
    }
    static modeString(str, mode) {
        let hash = this.getStringHashCode(str);
        let result = hash % mode;
        return result;
    }
    /**
     * 格式化字符串
     * @param str 包含有 0 个或者多个格式符的字符串
     * @param args
     * @returns 格式化后的新字符串
     * @performance 性能是+号拼接10分之1, 也就是比较慢, 要注意性能
     * ```
     * formatStr("hello {0}", "world") => hello world
     * formatStr("hello {0} {1} {0}", "world1", "world2") => hello world1 world2 world1
     * formatStr("hello {{qaq}} {0}", "world") => hello {qaq} world
     * ```
     */
    static formatStr(str, ...args) {
        let ret;
        // 开发阶段打印出错误
        if (typeof str != "string") {
            {
                let err = new Error('formatStr args[0] is not string');
                return err.name + err.stack;
            }
        }
        if (args.length == 0) {
            return str;
        }
        // 将{0}{1}替换成对应的参数 同时允许{{}}转化为{} 
        ret = str.replace(/\{\{|\}\}|\{(\d+)\}/g, function (m, n) {
            if (m == "{{") {
                return "{";
            }
            if (m == "}}") {
                return "}";
            }
            return args[n];
        });
        return ret;
    }
}

/**
 * 单例基类
 */
class Singleton {
    constructor() {
        this._isDisposed = false;
    }
    static getInst() {
        let self = this;
        ///@ts-ignore
        let inst = self._inst;
        if (inst == null) {
            throw new Error(`Singleton is not initialized, name is ${self.name}`);
        }
        return inst;
    }
    get isDisposed() {
        return this._isDisposed;
    }
    dispose() {
        this._onPreDestroy();
    }
    _onPreDestroy() {
        if (this._isDisposed) {
            return;
        }
        if (this.onDestroy) {
            this.onDestroy();
        }
        Singleton._inst = null;
        this._isDisposed = true;
    }
}

class Options extends Singleton {
    constructor() {
        super(...arguments);
        /**
         * 是否是服务端
         */
        this.isServer = false;
        /**
         * 进程序号
         */
        this.process = 1;
        /**
         * 区id
         */
        this.zone = 1;
        /**
         * log等级 越低输出信息越多
         * 不能控制框架层的输出
         */
        this.logLevel = 1;
        /**
         * 是否开发阶段
         * 开发阶段log会输出到控制台
         * 所以不要在生产环境设置为true
         */
        this.develop = true;
        /**
         * 控制台命令行输入
         */
        this.console = false;
        this._argsMap = new Map();
    }
    _setArgs(key, value) {
        this._argsMap.set(key, value);
    }
    /**
     * 获取启动参数
     * key 大小写敏感
     * @param key
     * @returns
     */
    getArgs(key) {
        {
            if (!this._argsMap.has(key)) {
                throw new Error(`Options.getArgs ${key} not exist`);
            }
        }
        return this._argsMap.get(key);
    }
}

/**
 * Logger
 */
class Logger extends Singleton {
    set iLog(value) {
        this._iLog = value;
    }
    log(str, ...args) {
        if (this.checkLogLevel(Logger.LOG_LEVEL)) {
            let formatStr = JsHelper.formatStr(str, ...args);
            this._iLog.log(formatStr);
        }
    }
    warn(str, ...args) {
        if (this.checkLogLevel(Logger.WARN_LEVEL)) {
            let formatStr = JsHelper.formatStr(str, ...args);
            this._iLog.warn(formatStr);
        }
    }
    /**
     * 错误打印会带上堆栈 用于定位错误
     * 错误打印不会受到logLevel的影响 一定会打印
     * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
     * @param str
     * @param args
     */
    error(str, ...args) {
        let formatStr = JsHelper.formatStr(str, ...args);
        let e = new Error();
        let errStr = JsHelper.formatStr('{0}, stack: {1}', formatStr, e.stack);
        this._iLog.error(errStr);
    }
    checkLogLevel(level) {
        return Options.getInst().logLevel <= level;
    }
    /**
     * 不受logLevel影响的log
     * @param str
     * @param args
     */
    coreLog(str, ...args) {
        let formatStr = JsHelper.formatStr(str, ...args);
        this._iLog.log(formatStr);
    }
    /**
     * 不受logLevel影响的log
     * @param str
     * @param args
     */
    coreWarn(str, ...args) {
        let formatStr = JsHelper.formatStr(str, ...args);
        this._iLog.warn(formatStr);
    }
    /**
     * 错误打印会带上堆栈 用于定位错误
     * 错误打印不会受到logLevel的影响 一定会打印
     * 非必要不要调用这个 特别是不要在在循环里面调用 否则日志文件两下就爆炸了
     * @param str
     * @param args
     */
    coreError(str, ...args) {
        let formatStr = JsHelper.formatStr(str, ...args);
        let e = new Error();
        let errStr = JsHelper.formatStr('{0}, stack: {1}', formatStr, e.stack);
        this._iLog.error(errStr);
    }
}
Logger.LOG_LEVEL = 1;
Logger.WARN_LEVEL = 2;
function log(str, ...args) {
    Logger.getInst().log(str, ...args);
}
function warn(str, ...args) {
    Logger.getInst().warn(str, ...args);
}
function error(str, ...args) {
    Logger.getInst().error(str, ...args);
}

// 框架内部用这个log 区分外部的log 不进行导出
function coreLog(str, ...args) {
    let formatStr = JsHelper.formatStr(str, ...args);
    let output = `[core]: ${formatStr}`;
    try {
        let inst = Logger.getInst();
        inst.coreLog(output);
    }
    catch (e) {
        console.log(output);
    }
}
function coreWarn(str, ...args) {
    let formatStr = JsHelper.formatStr(str, ...args);
    let output = `[core]: ${formatStr}`;
    try {
        let inst = Logger.getInst();
        inst.coreWarn(output);
    }
    catch (e) {
        console.warn(output);
    }
}
function coreError(str, ...args) {
    let formatStr = JsHelper.formatStr(str, ...args);
    let output = `[core]: ${formatStr}`;
    try {
        let inst = Logger.getInst();
        inst.coreError(output);
    }
    catch (e) {
        console.error(output);
    }
}

/**
 * 这个方法执行一个promise，如果promise出现异常，会打印异常信息
 * @param promise
 * @returns
 */
async function safeCall(promise) {
    try {
        return await promise;
    }
    catch (e) {
        coreError(e?.stack);
    }
}

/**
 * 客户端只需要用这一个消息处理器
 * 直接接收到的消息 且不需要回复
 */
class AMHandler {
    handle(session, msg) {
        // session可能已经断开了，所以这里需要判断
        if (session.isDisposed) {
            return;
        }
        {
            // 开发阶段检测
            let ret = this.run(session, msg);
            if (ret instanceof Promise) {
                coreWarn('{0}.run 请不要使用异步, 因为异步没办法保证消息接收后的处理顺序', this.constructor.name);
                safeCall(ret);
            }
        }
    }
}

class ObjectPool extends Singleton {
    constructor() {
        super(...arguments);
        this._pool = new Map;
    }
    fetch(type) {
        let queue = this._pool.get(type);
        if (!queue) {
            return new type();
        }
        if (queue.length === 0) {
            return new type();
        }
        return queue.shift();
    }
    recycle(obj) {
        let type = obj.constructor;
        let queue = this._pool.get(type);
        if (!queue) {
            queue = [];
            this._pool.set(type, queue);
        }
        if (queue.length > 1000) {
            // 报个警告 不进行缓存了
            console.warn(`pool ${type.name} is too large`);
            return;
        }
        queue.push(obj);
    }
}

class Task extends Promise {
    /**
     * 创建一个新的task
     * @param type
     * @returns
     */
    static create(type) {
        let resolveVar;
        let task = new Task((resolve, reject) => {
            resolveVar = resolve;
        });
        task._resolve = resolveVar;
        return task;
    }
    setResult(result) {
        if (!this._resolve) {
            coreError(`setResult task has been disposed`);
            return;
        }
        this._resolve(result);
        this.dispose();
    }
    /**
     * 不允许直接new
     * @param executor
     */
    constructor(executor) {
        super(executor);
    }
    dispose() {
        this._resolve = null;
    }
}

class Game {
    static addSingleton(singletonCtor) {
        if (Game.singletonMap.has(singletonCtor)) {
            throw new Error(`already exist singleton: ${singletonCtor.name}`);
        }
        let singleton = new singletonCtor();
        ///@ts-ignore
        singletonCtor._inst = singleton;
        Game.singletonMap.set(singletonCtor, singleton);
        Game.singletons.push(singleton);
        if (singleton.awake) {
            singleton.awake();
        }
        Game.destroys.push(singleton);
        if (singleton.update) {
            Game.updates.push(singleton);
        }
        if (singleton.lateUpdate) {
            Game.lateUpdates.push(singleton);
        }
        return singleton;
    }
    static async waitFrameFinish() {
        let task = Task.create();
        Game.frameFinishTaskQueue.push(task);
        await task;
    }
    static update() {
        for (let index = 0; index < Game.updates.length; index++) {
            let update = Game.updates[index];
            let singleton = update;
            if (singleton.isDisposed) {
                continue;
            }
            ///@ts-ignore
            update.update();
        }
    }
    static lateUpdate() {
        for (let index = 0; index < Game.lateUpdates.length; index++) {
            let lateUpdate = Game.lateUpdates[index];
            let singleton = lateUpdate;
            if (singleton.isDisposed) {
                continue;
            }
            ///@ts-ignore
            lateUpdate.lateUpdate();
        }
    }
    static frameFinishUpdate() {
        let len = Game.frameFinishTaskQueue.length;
        if (len == 0) {
            return;
        }
        for (let index = 0; index < len; index++) {
            const task = Game.frameFinishTaskQueue[index];
            task.setResult();
        }
        Game.frameFinishTaskQueue = [];
    }
    static dispose() {
        for (let index = Game.singletons.length - 1; index >= 0; index--) {
            let singleton = Game.singletons[index];
            if (singleton.isDisposed) {
                continue;
            }
            singleton._onPreDestroy();
        }
    }
}
Game.singletonMap = new Map;
Game.singletons = new Array;
Game.destroys = new Array;
Game.updates = new Array;
Game.lateUpdates = new Array;
Game.frameFinishTaskQueue = new Array;

/**
 * 需要忽略序列化的字段
 * 只能用在类的字段上
 * 原理就是禁止枚举 序列化的时候就不会序列化这个字段
 * @param target
 * @param name
 * @param desc
 * @returns
 */
const IgnoreSerialize = (target, name, desc) => {
    if (desc) {
        desc.enumerable = false;
        return desc;
    }
    Object.defineProperty(target, name, {
        set(value) {
            Object.defineProperty(this, name, {
                value, writable: true, configurable: true,
            });
        },
        configurable: true,
    });
};

var DecoratorTypeCore;
(function (DecoratorTypeCore) {
    DecoratorTypeCore["Event"] = "Event";
    DecoratorTypeCore["Invoke"] = "Invoke";
    DecoratorTypeCore["Message"] = "Message";
    DecoratorTypeCore["MessageParser"] = "MessageParser";
    DecoratorTypeCore["MessageResponse"] = "MessageResponse";
    DecoratorTypeCore["MessageHandler"] = "MessageHandler";
    DecoratorTypeCore["ActorMessageHandler"] = "ActorMessageHandler";
    DecoratorTypeCore["ConsoleHandler"] = "ConsoleHandler";
    DecoratorTypeCore["Transfer"] = "Transfer";
    DecoratorTypeCore["DB"] = "DB";
    DecoratorTypeCore["AIHandler"] = "AIHandler";
    DecoratorTypeCore["UI"] = "UI";
    DecoratorTypeCore["UILoader"] = "UILoader";
    DecoratorTypeCore["NumericWatcher"] = "NumericWatcher";
    DecoratorTypeCore["FrameFinishEvent"] = "FrameFinishEvent";
})(DecoratorTypeCore || (DecoratorTypeCore = {}));

class DecoratorCollector {
    constructor() {
        this.decorators = new Map;
    }
    static get inst() {
        if (DecoratorCollector._inst == null) {
            DecoratorCollector._inst = new DecoratorCollector;
        }
        return DecoratorCollector._inst;
    }
    add(decoratorType, ...args) {
        let array = this.decorators.get(decoratorType);
        if (!array) {
            array = new Array;
            this.decorators.set(decoratorType, array);
        }
        array.push(args);
    }
    get(decoratorType) {
        let array = this.decorators.get(decoratorType);
        return array || [];
    }
}

/**
 * 判断类是否有某个标记
 */
class FlagMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._datas = new Map;
    }
    add(decoratorType) {
        let list = DecoratorCollector.inst.get(decoratorType);
        let set = new Set;
        this._datas.set(decoratorType, set);
        for (const args of list) {
            let type = args[0];
            set.add(type);
        }
        return set;
    }
    hasFlag(decoratorType, type) {
        let set = this._datas.get(decoratorType);
        if (!set) {
            set = this.add(decoratorType);
        }
        return set.has(type);
    }
}

class TimeInfo extends Singleton {
    awake() {
        this.serverMinusClientTime = 0;
        this.frameTime = this.clientNow();
    }
    get ServerMinusClientTime() {
        return this.serverMinusClientTime;
    }
    set ServerMinusClientTime(value) {
        this.serverMinusClientTime = value;
    }
    update() {
        this.frameTime = this.clientNow();
    }
    clientNow() {
        return Math.floor(Date.now());
    }
    serverNow() {
        return this.clientNow() + this.serverMinusClientTime;
    }
    clientFrameTime() {
        return this.frameTime;
    }
    serverFrameTime() {
        return this.frameTime + this.serverMinusClientTime;
    }
}

class IdStruct {
    static generate() {
        if (this.lastTime == 0) {
            this.lastTime = this.timeSinceEpoch();
            if (this.lastTime <= 0) {
                coreWarn(`${(new this).constructor.name}: lastTime less than 0: ${this.lastTime}`);
                this.lastTime = 1;
            }
        }
        let time = this.timeSinceEpoch();
        if (time > this.lastTime) {
            this.lastTime = time;
            this.idCount = 0;
        }
        else {
            ++this.idCount;
            if (this.idCount > IdStruct.PowValueBit) {
                ++this.lastTime; // 借用下一秒
                this.idCount = 0;
                coreError(`${(new this).constructor.name}: idCount per sec overflow: ${time} ${this.lastTime}`);
            }
        }
        let struct = new this();
        struct.initArgs3(this.lastTime, Options.getInst().process, this.idCount);
        return struct.ToLong();
    }
    static timeSinceEpoch() {
        let a = (TimeInfo.getInst().frameTime - this.epoch) / 1000;
        return Math.floor(a);
    }
    ToLong() {
        let result = this.result.toNumber();
        return result;
    }
    initArgs1(id) {
        this.result = Long.fromNumber(id, true);
        this.Time = this.result.and(IdStruct.PowTimeBit).toNumber();
        this.Process = this.result.shiftRight(IdStruct.TimeBit)
            .and(IdStruct.PowProcessBit).toNumber();
        this.Value = this.result.shiftRight(IdStruct.TimeBit + IdStruct.ProcessBit)
            .and(IdStruct.PowValueBit).toNumber();
        return this;
    }
    initArgs2(process, value) {
        this.Time = 0;
        this.Process = process;
        this.Value = value;
        this.updateResult();
    }
    initArgs3(time, process, value) {
        this.Time = time;
        this.Process = process;
        this.Value = value;
        this.updateResult();
        return this;
    }
    updateResult() {
        this.result = Long.fromInt(0, true).or(this.Value)
            .shiftLeft(IdStruct.ProcessBit).or(this.Process)
            .shiftLeft(IdStruct.TimeBit).or(this.Time);
    }
}
IdStruct.epoch = new Date(2023, 4, 1).getTime();
IdStruct.lastTime = 0;
IdStruct.idCount = 0;
/**
 * 可用时间(s)
 * 8.5年
 */
IdStruct.TimeBit = 28; // 可用时间(s)
/**
 * 最大进程数量
 * 单区255进程
 */
IdStruct.ProcessBit = 8; // 最大进程数量
/**
 * 每秒可以产生的数量
 * 13w每秒
 */
IdStruct.ValueBit = 17; // 每秒可以产生的数量
IdStruct.PowTimeBit = Math.pow(2, IdStruct.TimeBit) - 1;
IdStruct.PowProcessBit = Math.pow(2, IdStruct.ProcessBit) - 1;
IdStruct.PowValueBit = Math.pow(2, IdStruct.ValueBit) - 1;

class InstanceIdStruct {
    static generate() {
        if (this.lastTime == 0) {
            this.lastTime = this.timeSinceEpoch();
            if (this.lastTime <= 0) {
                coreWarn(`${(new this).constructor.name}: lastTime less than 0: ${this.lastTime}`);
                this.lastTime = 1;
            }
        }
        let time = this.timeSinceEpoch();
        if (time > this.lastTime) {
            this.lastTime = time;
            this.idCount = 0;
        }
        else {
            ++this.idCount;
            if (this.idCount > InstanceIdStruct.PowValueBit) {
                ++this.lastTime; // 借用下一秒
                this.idCount = 0;
                coreError(`${(new this).constructor.name}: idCount per sec overflow: ${time} ${this.lastTime}`);
            }
        }
        let struct = new this();
        struct.initArgs3(this.lastTime, Options.getInst().process, this.idCount);
        return struct.ToLong();
    }
    static timeSinceEpoch() {
        let a = (TimeInfo.getInst().frameTime - this.epoch) / 1000;
        return Math.floor(a);
    }
    ToLong() {
        let result = this.result.toNumber();
        return result;
    }
    initArgs1(id) {
        this.result = Long.fromNumber(id, true);
        this.Time = this.result.and(InstanceIdStruct.PowTimeBit).toNumber();
        this.Process = this.result.shiftRight(InstanceIdStruct.TimeBit)
            .and(InstanceIdStruct.PowProcessBit).toNumber();
        this.Value = this.result.shiftRight(InstanceIdStruct.TimeBit + InstanceIdStruct.ProcessBit)
            .and(InstanceIdStruct.PowValueBit).toNumber();
        return this;
    }
    initArgs2(process, value) {
        this.Time = 0;
        this.Process = process;
        this.Value = value;
        this.updateResult();
    }
    initArgs3(time, process, value) {
        this.Time = time;
        this.Process = process;
        this.Value = value;
        this.updateResult();
        return this;
    }
    updateResult() {
        this.result = Long.fromInt(0, true).or(this.Value)
            .shiftLeft(InstanceIdStruct.ProcessBit).or(this.Process)
            .shiftLeft(InstanceIdStruct.TimeBit).or(this.Time);
    }
}
InstanceIdStruct.epoch = new Date(2023, 4, 2).getTime();
InstanceIdStruct.lastTime = 0;
InstanceIdStruct.idCount = 0;
/**
 * 可用时间(s)
 * 8.5年
 */
InstanceIdStruct.TimeBit = 28;
/**
 * 最大进程数量
 * 单区255进程
 */
InstanceIdStruct.ProcessBit = 8;
/**
 * 每秒可以产生的数量
 * 13w每秒
 */
InstanceIdStruct.ValueBit = 17;
InstanceIdStruct.PowTimeBit = Math.pow(2, InstanceIdStruct.TimeBit) - 1;
InstanceIdStruct.PowProcessBit = Math.pow(2, InstanceIdStruct.ProcessBit) - 1;
InstanceIdStruct.PowValueBit = Math.pow(2, InstanceIdStruct.ValueBit) - 1;

class IdGenerator extends Singleton {
    awake() {
    }
    generateInstanceId() {
        return InstanceIdStruct.generate();
    }
    generateId() {
        return IdStruct.generate();
    }
}

var __decorate$w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EntityStatus;
(function (EntityStatus) {
    EntityStatus[EntityStatus["None"] = 0] = "None";
    EntityStatus[EntityStatus["IsFromPool"] = 1] = "IsFromPool";
    EntityStatus[EntityStatus["IsRegister"] = 2] = "IsRegister";
    EntityStatus[EntityStatus["IsComponent"] = 4] = "IsComponent";
    EntityStatus[EntityStatus["IsCreated"] = 8] = "IsCreated";
    EntityStatus[EntityStatus["IsNew"] = 16] = "IsNew";
})(EntityStatus || (EntityStatus = {}));
class Entity {
    constructor() {
        this.status = EntityStatus.None;
    }
    get parent() {
        return this._parent;
    }
    set parent(value) {
        if (value == null) {
            throw new Error(`cant set parent null: ${this.constructor.name}`);
        }
        if (value == this) {
            throw new Error(`cant set parent self: ${this.constructor.name}`);
        }
        if (value.domain == null) {
            throw new Error(`cant set parent because parent domain is null: ${this.constructor.name} ${value.constructor.name}`);
        }
        if (this._parent != null) // 之前有parent
         {
            // parent相同，不设置
            if (this._parent == value) {
                throw new Error(`重复设置了Parent: ${this.constructor.name} parent: ${this._parent.constructor.name}`);
            }
            this._parent.removeFromChildren(this);
        }
        this._parent = value;
        this.isComponent = false;
        this._parent.addToChildren(this);
        this.domain = this.parent.domain;
    }
    get domain() {
        return this._domain;
    }
    set domain(value) {
        if (value == null) {
            throw new Error(`domain cant set null: ${this.constructor.name}`);
        }
        if (this._domain == value) {
            return;
        }
        let preDomain = this._domain;
        this._domain = value;
        if (preDomain == null) {
            this.instanceId = IdGenerator.getInst().generateInstanceId();
            this.isRegister = true;
            // 反序列化出来的需要设置父子关系
            if (this.componentsDB != null) {
                for (let component of this.componentsDB) {
                    component.isComponent = true;
                    this.components.set(component.constructor, component);
                    component._parent = this;
                }
            }
            if (this.childrenDB != null) {
                for (let child of this.childrenDB) {
                    child.isComponent = false;
                    this.children.set(child.id, child);
                    child._parent = this;
                }
            }
        }
        // 递归设置孩子的Domain
        if (this._children != null) {
            for (let [id, entity] of this._children.entries()) {
                entity.domain = this._domain;
            }
        }
        if (this._components != null) {
            for (let [type, component] of this._components.entries()) {
                component.domain = this._domain;
            }
        }
        if (!this.isCreated) {
            this.isCreated = true;
        }
    }
    get isDisposed() {
        return this.instanceId == 0;
    }
    get children() {
        return this._children ?? (this._children = ObjectPool.getInst().fetch(Map));
    }
    get components() {
        return this._components ?? (this._components = ObjectPool.getInst().fetch(Map));
    }
    get isFromPool() {
        return (this.status & EntityStatus.IsFromPool) == EntityStatus.IsFromPool;
    }
    set isFromPool(value) {
        if (value) {
            this.status |= EntityStatus.IsFromPool;
        }
        else {
            this.status &= ~EntityStatus.IsFromPool;
        }
    }
    get isComponent() {
        return (this.status & EntityStatus.IsComponent) == EntityStatus.IsComponent;
    }
    set isComponent(value) {
        if (value) {
            this.status |= EntityStatus.IsComponent;
        }
        else {
            this.status &= ~EntityStatus.IsComponent;
        }
    }
    get isCreated() {
        return (this.status & EntityStatus.IsCreated) == EntityStatus.IsCreated;
    }
    set isCreated(value) {
        if (value) {
            this.status |= EntityStatus.IsCreated;
        }
        else {
            this.status &= ~EntityStatus.IsCreated;
        }
    }
    get isNew() {
        return (this.status & EntityStatus.IsNew) == EntityStatus.IsNew;
    }
    set isNew(value) {
        if (value) {
            this.status |= EntityStatus.IsNew;
        }
        else {
            this.status &= ~EntityStatus.IsNew;
        }
    }
    get isRegister() {
        return (this.status & EntityStatus.IsRegister) == EntityStatus.IsRegister;
    }
    set isRegister(value) {
        if (this.isRegister == value) {
            return;
        }
        if (value) {
            this.status |= EntityStatus.IsRegister;
        }
        else {
            this.status &= ~EntityStatus.IsRegister;
        }
        if (!value) {
            Entity.IRoot.remove(this.instanceId);
        }
        else {
            Entity.IRoot.add(this);
            Entity.IEventSystem.registerSystem(this);
        }
    }
    set componentParent(value) {
        if (value == null) {
            throw new Error(`cant set parent null: ${this.constructor.name}`);
        }
        if (value == this) {
            throw new Error(`cant set parent self: ${this.constructor.name}`);
        }
        // 严格限制parent必须要有domain,也就是说parent必须在数据树上面
        if (value.domain == null) {
            throw new Error(`cant set parent because parent domain is null: ${this.constructor.name} ${value.constructor.name}`);
        }
        if (this.parent != null) // 之前有parent
         {
            // parent相同，不设置
            if (this.parent == value) {
                throw new Error(`重复设置了Parent: ${this.constructor.name} parent: ${this.parent.constructor.name}`);
            }
            this.parent.removeFromComponents(this);
        }
        this._parent = value;
        this.isComponent = true;
        this._parent.addToComponents(this);
        this.domain = this.parent.domain;
    }
    addComponent(componentOrType, isFromPool) {
        if (componentOrType instanceof Entity) {
            return this.addComponentByEntity(componentOrType);
        }
        else {
            return this.addComponentByCtor(componentOrType, isFromPool);
        }
    }
    tryAddComponent(type) {
        let com = this.getComponent(type);
        if (com == null) {
            com = this.addComponent(type);
        }
        return com;
    }
    addComponentByEntity(component) {
        let type = component.constructor;
        if (this._components != null && this._components.has(type)) {
            throw new Error(`entity already has component: ${type.name}`);
        }
        component.componentParent = this;
        return component;
    }
    addComponentByCtor(type, isFromPool = false) {
        if (this._components != null && this._components.has(type)) {
            throw new Error(`entity already has component: ${type.name}`);
        }
        let component = this.create(type, isFromPool);
        component.id = this.id;
        component.componentParent = this;
        if (component.awake) {
            Entity.IEventSystem.awakeComEvent(component);
        }
        return component;
    }
    addChild(entityOrType, isFromPool) {
        if (entityOrType instanceof Entity) {
            return this.addChildByEntity(entityOrType);
        }
        else {
            return this.addChildByCtor(entityOrType, isFromPool);
        }
    }
    addChildWithId(type, id, isFromPool = false) {
        let component = this.create(type, isFromPool);
        component.id = id;
        component.parent = this;
        if (component.awake) {
            Entity.IEventSystem.awakeComEvent(component);
        }
        return component;
    }
    addChildByEntity(entity) {
        entity.parent = this;
        return entity;
    }
    addChildByCtor(type, isFromPool = false) {
        let component = this.create(type, isFromPool);
        component.id = IdGenerator.getInst().generateId();
        component.parent = this;
        if (component.awake) {
            Entity.IEventSystem.awakeComEvent(component);
        }
        return component;
    }
    create(type, isFromPool) {
        let component;
        if (isFromPool) {
            component = ObjectPool.getInst().fetch(type);
        }
        else {
            component = new type;
        }
        component.isFromPool = isFromPool;
        component.isCreated = true;
        component.isNew = true;
        component.id = 0;
        return component;
    }
    removeFromChildren(entity) {
        if (this._children == null) {
            return;
        }
        this._children.delete(entity.id);
        if (this._children.size == 0) {
            ObjectPool.getInst().recycle(this._children);
            this._children = null;
        }
        this.removeFromChildrenDB(entity);
    }
    removeFromChildrenDB(entity) {
        if (!FlagMgr.getInst().hasFlag(DecoratorTypeCore.DB, entity.constructor)) {
            return;
        }
        if (this.childrenDB == null) {
            return;
        }
        this.childrenDB.delete(entity);
        if (this.childrenDB.size == 0 && this.isNew) {
            ObjectPool.getInst().recycle(this.childrenDB);
            this.childrenDB = null;
        }
    }
    removeFromComponents(component) {
        if (this._components == null) {
            return;
        }
        this._components.delete(component.constructor);
        if (this._components.size == 0) {
            ObjectPool.getInst().recycle(this._components);
            this._components = null;
        }
        this.removeFromComponentsDB(component);
    }
    removeFromComponentsDB(component) {
        if (!FlagMgr.getInst().hasFlag(DecoratorTypeCore.DB, component.constructor)) {
            return;
        }
        if (this.componentsDB == null) {
            return;
        }
        this.componentsDB.delete(component);
        if (this.componentsDB.size == 0 && this.isNew) {
            ObjectPool.getInst().recycle(this.componentsDB);
            this.componentsDB = null;
        }
    }
    addToComponents(component) {
        this.components.set(component.constructor, component);
        this.AddToComponentsDB(component);
    }
    AddToComponentsDB(component) {
        // 没有db这个标志就不添加到componentsDB
        if (!FlagMgr.getInst().hasFlag(DecoratorTypeCore.DB, component.constructor)) {
            return;
        }
        this.componentsDB ?? (this.componentsDB = ObjectPool.getInst().fetch(Set));
        this.componentsDB.add(component);
    }
    AddToChildrenDB(entity) {
        if (!FlagMgr.getInst().hasFlag(DecoratorTypeCore.DB, entity.constructor)) {
            return;
        }
        this.childrenDB ?? (this.childrenDB = ObjectPool.getInst().fetch(Set));
        this.childrenDB.add(entity);
    }
    addToChildren(entity) {
        if (this.children.has(entity.id)) {
            throw new Error(`entity already has child: ${entity.id}`);
        }
        this.children.set(entity.id, entity);
        this.AddToChildrenDB(entity);
    }
    getComponent(type) {
        if (this._components == null) {
            return null;
        }
        let component = this._components.get(type);
        if (!component) {
            return null;
        }
        return component;
    }
    removeComponent(type) {
        if (this.isDisposed) {
            return;
        }
        if (this._components == null) {
            return;
        }
        let c = this.getComponent(type);
        if (c == null) {
            return;
        }
        this.removeFromComponents(c);
        c.dispose();
    }
    getParent(type) {
        return this.parent;
    }
    getChild(type, id) {
        if (this._children == null) {
            return null;
        }
        let child = this._children.get(id);
        return child;
    }
    removeChild(id) {
        if (this._children == null) {
            return;
        }
        let child = this._children.get(id);
        if (!child) {
            return;
        }
        this._children.delete(id);
        child.dispose();
    }
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.isRegister = false;
        this.instanceId = 0;
        // 清理Children
        if (this._children != null) {
            for (let [id, entity] of this._children.entries()) {
                entity.dispose();
            }
            this._children.clear();
            ObjectPool.getInst().recycle(this._children);
            this._children = null;
            if (this.childrenDB != null) {
                this.childrenDB.clear();
                // 创建的才需要回到池中,从db中不需要回收
                if (this.isNew) {
                    ObjectPool.getInst().recycle(this.childrenDB);
                    this.childrenDB = null;
                }
            }
        }
        // 清理Component
        if (this._components != null) {
            for (let [entityCtor, entity] of this._components.entries()) {
                entity.dispose();
            }
            this._components.clear();
            ObjectPool.getInst().recycle(this._components);
            this._components = null;
            if (this.componentsDB != null) {
                this.componentsDB.clear();
                if (this.isNew) {
                    ObjectPool.getInst().recycle(this.componentsDB);
                    this.componentsDB = null;
                }
            }
        }
        // 触发Destroy事件
        if (this.destroy) {
            Entity.IEventSystem.destroyComEvent(this);
        }
        this._domain = null;
        if (this._parent != null && !this._parent.isDisposed) {
            if (this.isComponent) {
                this._parent.removeComponent(this.getType());
            }
            else {
                this._parent.removeFromChildren(this);
            }
        }
        this._parent = null;
        if (this.isFromPool) {
            ObjectPool.getInst().recycle(this);
        }
        this.status = EntityStatus.None;
    }
    domainScene() {
        return this.domain;
    }
    getType() {
        return this.constructor;
    }
}
__decorate$w([
    IgnoreSerialize
], Entity.prototype, "instanceId", void 0);
__decorate$w([
    IgnoreSerialize
], Entity.prototype, "_domain", void 0);
__decorate$w([
    IgnoreSerialize
], Entity.prototype, "_children", void 0);
__decorate$w([
    IgnoreSerialize
], Entity.prototype, "_components", void 0);
__decorate$w([
    IgnoreSerialize
], Entity.prototype, "_parent", void 0);
__decorate$w([
    IgnoreSerialize
], Entity.prototype, "status", void 0);

class TypeNameCore {
}
TypeNameCore.Scene = "Scene";

/**
 * 用来解耦合的，用于收集构造函数
 */
class TypeCollector {
    constructor() {
        this.ctors = new Map;
    }
    static get inst() {
        if (TypeCollector._inst == null) {
            TypeCollector._inst = new TypeCollector;
        }
        return TypeCollector._inst;
    }
    add(name, type) {
        if (this.ctors.has(name)) {
            console.error(`type ${name} already exists`);
            return;
        }
        this.ctors.set(name, type);
    }
    get(name) {
        let type = this.ctors.get(name);
        if (type == null) {
            console.error(`type ${name} not found`);
        }
        return type;
    }
}

/**
 * 收集class的构造函数 避免耦合
 * @param name
 * @returns
 */
function TypeCollectorDecorator(name) {
    return function (constructor) {
        TypeCollector.inst.add(name, constructor);
    };
}

var __decorate$v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Scene = class Scene extends Entity {
    set domain(value) {
        this._domain = value;
    }
    get domain() {
        return this._domain;
    }
    set parent(value) {
        if (value == null) {
            return;
        }
        this._parent = value;
        this._parent.children.set(this.id, this);
    }
    init(args) {
        this.id = args.id;
        this.instanceId = args.instanceId;
        this.sceneType = args.sceneType;
        this.name = args.name;
        this.parent = args.parent;
        this.isCreated = true;
        this.isNew = true;
        this.domain = this;
        this.isRegister = true;
        coreLog(`scene create sceneType = {0}, name = {1}, id = {2}`, this.sceneType, this.name, this.id);
    }
};
Scene = __decorate$v([
    TypeCollectorDecorator(TypeNameCore.Scene)
], Scene);

class EntityIRootLoader {
    static run(root) {
        Entity.IRoot = root;
    }
}

class EntitySceneFactory {
    static createScene(args) {
        if (args.instanceId == null) {
            args.instanceId = IdGenerator.getInst().generateInstanceId();
        }
        let type = TypeCollector.inst.get(TypeNameCore.Scene);
        let scene = (new type);
        scene.init(args);
        return scene;
    }
}

var SceneTypeCore$1;
(function (SceneTypeCore) {
    SceneTypeCore["None"] = "None";
    SceneTypeCore["Process"] = "Process";
    SceneTypeCore["Client"] = "Client";
    SceneTypeCore["Current"] = "Current";
})(SceneTypeCore$1 || (SceneTypeCore$1 = {}));

class Root extends Singleton {
    constructor() {
        super(...arguments);
        this.allEntities = new Map;
    }
    get scene() {
        return this._scene;
    }
    awake() {
        EntityIRootLoader.run(this);
        this._scene = EntitySceneFactory.createScene({ id: 0, sceneType: SceneTypeCore$1.Process, name: "Process" });
    }
    destroy() {
    }
    add(entity) {
        this.allEntities.set(entity.instanceId, entity);
    }
    remove(instanceId) {
        this.allEntities.delete(instanceId);
    }
    get(instanceId) {
        let component = this.allEntities.get(instanceId);
        return component;
    }
}

var MessageTypeCore;
(function (MessageTypeCore) {
    MessageTypeCore["Message"] = "Message";
    MessageTypeCore["Request"] = "Request";
    MessageTypeCore["Response"] = "Response";
    MessageTypeCore["ActorMessage"] = "ActorMessage";
    MessageTypeCore["ActorRequest"] = "ActorRequest";
    MessageTypeCore["ActorResponse"] = "ActorResponse";
    MessageTypeCore["ActorLocationMessage"] = "ActorLocationMessage";
    MessageTypeCore["ActorLocationRequest"] = "ActorLocationRequest";
    MessageTypeCore["ActorLocationResponse"] = "ActorLocationResponse";
})(MessageTypeCore || (MessageTypeCore = {}));

/**
 * 消息类型管理器
 * 比如通过opcode得到MessageType
 * 或者通过Type得到MessageType
 */
class MessageTypeMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._messageTypeMap = new Map;
        this._typeToMessageTypeMap = new Map;
    }
    awake() {
        let list = DecoratorCollector.inst.get(DecoratorTypeCore.Message);
        for (const args of list) {
            let type = args[0];
            let msgType = args[1];
            let opcode = args[2];
            this._messageTypeMap.set(opcode, msgType);
            this._typeToMessageTypeMap.set(type, msgType);
        }
    }
    destroy() {
        this._messageTypeMap.clear();
        this._messageTypeMap = null;
    }
    getMessageType(type) {
        return this._typeToMessageTypeMap.get(type);
    }
    isResponse(opcode) {
        let msgType = this._messageTypeMap.get(opcode);
        if (!msgType) {
            return false;
        }
        if (msgType == MessageTypeCore.Response) {
            return true;
        }
        if (msgType == MessageTypeCore.ActorResponse) {
            return true;
        }
        if (msgType == MessageTypeCore.ActorLocationResponse) {
            return true;
        }
        return false;
    }
}

/**
 * 可通过value获取key的map
 */
class DoubleMap {
    constructor() {
        this.kv = new Map;
        this.vk = new Map;
    }
    *iterator() {
        for (const [k, v] of this.kv) {
            yield k;
        }
    }
    Add(key, value) {
        if (key == null || value == null || this.kv.has(key) || this.vk.has(value)) {
            return;
        }
        this.kv.set(key, value);
        this.vk.set(value, key);
    }
    GetValueByKey(key) {
        if (key != null && this.kv.has(key)) {
            return this.kv.get(key);
        }
        return null;
    }
    GetKeyByValue(value) {
        if (value != null && this.vk.has(value)) {
            return this.vk.get(value);
        }
        return null;
    }
    RemoveByKey(key) {
        if (key == null) {
            return;
        }
        let value = this.kv.get(key);
        if (!value) {
            return;
        }
        this.kv.delete(key);
        this.vk.delete(value);
    }
    Clear() {
        this.kv.clear();
        this.vk.clear();
    }
}

class NetServices extends Singleton {
    constructor() {
        super(...arguments);
        this.acceptIdGenerator = Number.MAX_SAFE_INTEGER - 1;
        this.typeOpcode = new DoubleMap();
        this.services = new Map;
        this.queue = new Array;
        this.serviceIdGenerator = 0;
        this.acceptCallback = new Map;
        this.readCallback = new Map;
        this.errorCallback = new Map;
    }
    awake() {
        let list = DecoratorCollector.inst.get(DecoratorTypeCore.Message);
        for (const args of list) {
            let opcode = args[2];
            args[1];
            let messageCtor = args[0];
            this.typeOpcode.Add(messageCtor, opcode);
        }
    }
    SendMessage(serviceId, channelId, actorId, message) {
        let service = this.Get(serviceId);
        if (service != null) {
            service.Send(channelId, actorId, message);
        }
    }
    AddService(aService) {
        aService.Id = ++this.serviceIdGenerator;
        this.Add(aService);
        return aService.Id;
    }
    RemoveService(serviceId) {
        this.Remove(serviceId);
    }
    CreateChannel(serviceId, channelId, address) {
        let service = this.Get(serviceId);
        if (service != null) {
            service.Create(channelId, address);
        }
    }
    RemoveChannel(serviceId, channelId, error) {
        let service = this.Get(serviceId);
        if (service != null) {
            service.Remove(channelId, error);
        }
    }
    RegisterAcceptCallback(serviceId, action) {
        this.acceptCallback.set(serviceId, action);
    }
    RegisterReadCallback(serviceId, action) {
        this.readCallback.set(serviceId, action);
    }
    /**
     * 一个serviceId只能注册一个
     * @param serviceId
     * @param action
     */
    RegisterErrorCallback(serviceId, action) {
        {
            if (this.errorCallback.has(serviceId)) {
                coreError(`重复注册servece的errorCallback, serviceId=${serviceId}`);
            }
        }
        this.errorCallback.set(serviceId, action);
    }
    OnAccept(serviceId, channelId, ipEndPoint) {
        let cb = this.acceptCallback.get(serviceId);
        if (!cb) {
            return;
        }
        cb(channelId, ipEndPoint);
    }
    OnRead(serviceId, channelId, actorId, message) {
        let cb = this.readCallback.get(serviceId);
        if (!cb) {
            return;
        }
        cb(channelId, actorId, message);
    }
    OnError(serviceId, channelId, error) {
        let cb = this.errorCallback.get(serviceId);
        if (!cb) {
            return;
        }
        cb(channelId, error);
    }
    Get(id) {
        return this.services.get(id);
    }
    Add(aService) {
        this.services.set(aService.Id, aService);
        this.queue.push(aService.Id);
    }
    Remove(id) {
        let service = this.services.get(id);
        if (service) {
            service.Dispose();
        }
    }
    GetOpcode(type) {
        return this.typeOpcode.GetValueByKey(type);
    }
    GetType(opcode) {
        return this.typeOpcode.GetKeyByValue(opcode);
    }
    CreateAcceptChannelId() {
        return --this.acceptIdGenerator;
    }
}

/**
 * 消息打印器
 */
class MsgPrinter extends Singleton {
    constructor() {
        super(...arguments);
        this._ignoreDebugLogMessages = new Set();
        /**
         * 是否需要在收到消息的时候打印
         */
        this._isLog = true;
        /**
         * 是否需要print
         * 如果为false 那么所有print都不会打印
         */
        this._isPrint = true;
    }
    isNeedLogMessage(opcode) {
        if (this._ignoreDebugLogMessages.has(opcode)) {
            return false;
        }
        return true;
    }
    replacer(key, value) {
        if (value instanceof Map) {
            if (value.size > 10) {
                return `Map length: ${value.size}`;
            }
            else {
                return {
                    dataType: 'Map',
                    value: Array.from(value.entries()), // or with spread: value: [...value]
                };
            }
        }
        else if (value instanceof Uint8Array) {
            return `Uint8Array length: ${value.byteLength}`;
        }
        else if (value instanceof Set) {
            if (value.size > 10) {
                return `Set length: ${value.size}`;
            }
            else {
                return {
                    dataType: 'Set',
                    value: Array.from(value.entries()), // or with spread: value: [...value]
                };
            }
        }
        else if (value instanceof Array) {
            if (value.length > 10) {
                return `Array length: ${value.length}`;
            }
            else {
                return value;
            }
        }
        else {
            return value;
        }
    }
    /**
     * 供收到消息的时候调用 可以忽略一些消息的打印
     * @param message
     * @returns
     */
    log(message, prefix = '') {
        if (!Options.getInst().develop) {
            return;
        }
        if (!this._isLog) {
            return;
        }
        let opcode = NetServices.getInst().GetOpcode(message.constructor);
        if (!this.isNeedLogMessage(opcode)) {
            return;
        }
        coreLog(`[MsgPrinter.l] ${prefix}${message.constructor.name}:${JSON.stringify(message, this.replacer)}`);
    }
    /**
     * 直接打印出消息
     * @param message
     */
    print(message, prefix = '') {
        if (!this._isPrint) {
            return;
        }
        coreLog(`[MsgPrinter.p] ${prefix}${message.constructor.name}:${JSON.stringify(message, this.replacer)}`);
    }
    /**
     * 将消息转化成string
     * @param message
     * @returns
     */
    getMsgString(message) {
        return `${message.constructor.name}:${JSON.stringify(message, this.replacer)}`;
    }
    ignore(opcode) {
        this._ignoreDebugLogMessages.add(opcode);
    }
    closePrint() {
        this._isPrint = false;
    }
    closeLog() {
        this._isLog = false;
    }
}

class MessageDispatcherInfo {
    constructor(sceneType, msgHandler, responseType) {
        this.sceneType = sceneType;
        this.msgHandler = msgHandler;
        this.responseType = responseType;
    }
}
/**
 * 普通消息分发
 * 也就是直接到达的消息
 * 客户端跟服务端都有使用
 */
class MessageDispatcherMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._handlers = new Map;
    }
    awake() {
        this.load();
    }
    destroy() {
        this._handlers.clear();
    }
    registerHandler(msgType, handler) {
        if (!this._handlers.has(msgType)) {
            this._handlers.set(msgType, new Array());
        }
        this._handlers.get(msgType).push(handler);
    }
    load() {
        let list = DecoratorCollector.inst.get(DecoratorTypeCore.MessageHandler);
        for (const args of list) {
            let msgHandlerType = args[0];
            let msgType = args[1];
            let sceneType = args[2];
            let responseMsgType = args[3];
            let handler = new msgHandlerType();
            let msgDispatcherInfo = new MessageDispatcherInfo(sceneType, handler, responseMsgType);
            this.registerHandler(msgType, msgDispatcherInfo);
        }
    }
    handle(session, message) {
        let type = message.constructor;
        let actions = this._handlers.get(type);
        if (!actions) {
            let opcode = NetServices.getInst().GetOpcode(type);
            MsgPrinter.getInst().print(message, `消息没有处理: opcode=${opcode}`);
            return;
        }
        let sceneType = session.domainScene().sceneType;
        for (const messageDispatcherInfo of actions) {
            if (messageDispatcherInfo.sceneType != sceneType) {
                continue;
            }
            messageDispatcherInfo.msgHandler.handle(session, message, messageDispatcherInfo.responseType);
        }
    }
}

/**
 * 可回收对象
 */
class RecycleObj {
    constructor() {
        this._isRecycle = false;
    }
    /**
     * 通过对象池创建
     * @param this
     * @param values
     * @returns
     */
    static create(values) {
        let event = ObjectPool.getInst().fetch(this);
        if (values) {
            Object.assign(event, values);
        }
        event._isRecycle = true;
        return event;
    }
    /**
     * 如果是通过create方法创建的
     * 那么dispose会回收到对象池
     */
    dispose() {
        if (this._isRecycle) {
            ObjectPool.getInst().recycle(this);
        }
    }
}

class AWait extends RecycleObj {
    constructor() {
        super(...arguments);
        this.error = 0;
    }
}

class TimeHelper {
    static clientNow() {
        return TimeInfo.getInst().clientNow();
    }
    static clientNowSeconds() {
        return Math.floor(TimeHelper.clientNow() / 1000);
    }
    static dateTimeNow() {
        return new Date();
    }
    static serverNow() {
        return TimeInfo.getInst().serverNow();
    }
    static clientFrameTime() {
        return TimeInfo.getInst().clientFrameTime();
    }
    static serverFrameTime() {
        return TimeInfo.getInst().serverFrameTime();
    }
}
TimeHelper.OneDay = 86400000;
TimeHelper.Hour = 3600000;
TimeHelper.Minute = 60000;

var TimerType;
(function (TimerType) {
    TimerType[TimerType["Once"] = 0] = "Once";
    TimerType[TimerType["Repeat"] = 1] = "Repeat";
    TimerType[TimerType["Task"] = 2] = "Task";
})(TimerType || (TimerType = {}));
class Timer {
    static GetId() {
        return ++this._idGenerator;
    }
    static create() {
        let timer = ObjectPool.getInst().fetch(Timer);
        timer.reset();
        timer.id = Timer.GetId();
        return timer;
    }
    reset() {
        this.cb = null;
        this.tcs = null;
        this.id = 0;
        this.expireTime = 0;
        this.interval = 0;
    }
    dispose() {
        this.reset();
        ObjectPool.getInst().recycle(this);
    }
}
Timer._idGenerator = 1000;
class TimerMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._timerMap = new Map;
        this._timers = [];
    }
    /**
     * 不断重复的定时器
     * @param time ms
     * @param callback
     * @returns
     */
    newRepeatedTimer(time, callback) {
        let timer = Timer.create();
        timer.type = TimerType.Repeat;
        timer.cb = callback;
        timer.interval = time;
        timer.expireTime = time + TimeHelper.clientNow();
        this._timerMap.set(timer.id, timer);
        this._timers.push(timer);
        return timer.id;
    }
    newOnceTimer(timeout, callback) {
        let timer = Timer.create();
        timer.type = TimerType.Once;
        timer.cb = callback;
        timer.expireTime = timeout + TimeHelper.clientNow();
        this._timerMap.set(timer.id, timer);
        this._timers.push(timer);
        return timer.id;
    }
    newFrameTimer(callback) {
        let timer = Timer.create();
        timer.type = TimerType.Repeat;
        timer.cb = callback;
        // 服务端的帧时间设置100ms 不需要那么精细
        if (Options.getInst().isServer) {
            timer.interval = 100;
        }
        else {
            timer.interval = 1;
        }
        timer.expireTime = timer.interval + TimeHelper.clientNow();
        this._timerMap.set(timer.id, timer);
        this._timers.push(timer);
        return timer.id;
    }
    remove(id) {
        let timer = this._timerMap.get(id);
        if (!timer) {
            return false;
        }
        timer.id = 0;
        this._timerMap.delete(id);
        return true;
    }
    /**
     * 浏览器上会有一个问题
     * 就是cocos的update后台不执行,但是js脚本依然执行，导致大量的timer没回收
     * 暂时不处理这个问题 应该没什么影响
     */
    update() {
        let nowTime = TimeHelper.clientNow();
        for (let i = this._timers.length - 1; i >= 0; i--) {
            let timer = this._timers[i];
            if (timer.id == 0) {
                this._timers.splice(i, 1);
                timer.dispose();
                continue;
            }
            if (timer.expireTime > nowTime) {
                continue;
            }
            if (timer.cb != null) {
                timer.cb();
            }
            if (timer.tcs != null) {
                timer.tcs.setResult();
            }
            if (timer.type == TimerType.Repeat) {
                timer.expireTime += timer.interval;
            }
            else {
                this.remove(timer.id);
                continue;
            }
        }
    }
    /**
     *
     * @param time ms
     * @param cancellationToken
     * @returns
     */
    async waitAsync(time, cancellationToken) {
        if (time == 0) {
            return;
        }
        let tcs = Task.create();
        let timer = Timer.create();
        timer.type = TimerType.Once;
        timer.tcs = tcs;
        timer.expireTime = time + TimeHelper.clientNow();
        this._timerMap.set(timer.id, timer);
        this._timers.push(timer);
        let cancelAction;
        if (cancellationToken) {
            cancelAction = () => {
                if (this.remove(timer.id)) {
                    tcs.setResult();
                }
            };
            cancellationToken.add(cancelAction);
        }
        try {
            await tcs;
        }
        finally {
            cancellationToken?.remove(cancelAction);
            cancelAction = null;
        }
    }
}

var WaitError;
(function (WaitError) {
    WaitError[WaitError["Success"] = 0] = "Success";
    WaitError[WaitError["Destroy"] = 1] = "Destroy";
    WaitError[WaitError["Cancel"] = 2] = "Cancel";
    WaitError[WaitError["Timeout"] = 3] = "Timeout";
})(WaitError || (WaitError = {}));

class ObjectWait extends Entity {
    constructor() {
        super(...arguments);
        this.tcss = new Map;
    }
    /**
     * 一直等待 知道notify了 永不超时
     * @param type
     * @param cancellationToken
     * @returns
     */
    async wait(type, cancellationToken) {
        this.cancelLastWait(type);
        let tcs = Task.create(type);
        this.tcss.set(type, tcs);
        let cancelAction;
        let ret;
        if (cancellationToken) {
            cancelAction = () => {
                let obj = new type();
                obj.error = WaitError.Cancel;
                this.notify(obj);
            };
            cancellationToken.add(cancelAction);
        }
        try {
            ret = await tcs;
        }
        finally {
            cancellationToken?.remove(cancelAction);
            cancelAction = null;
        }
        return ret;
    }
    /**
     * 等待且有超时限制 超时将会取消等待
     * @param type
     * @param timeout ms
     * @param cancellationToken
     * @returns
     */
    async waitWithTimeout(type, timeout, cancellationToken) {
        this.cancelLastWait(type);
        let tcs = Task.create(type);
        this.tcss.set(type, tcs);
        this.timeoutRun(type, timeout, cancellationToken);
        let cancelAction;
        let ret;
        if (cancellationToken) {
            cancelAction = () => {
                let obj = new type();
                obj.error = WaitError.Cancel;
                this.notify(obj);
            };
            cancellationToken.add(cancelAction);
        }
        try {
            ret = await tcs;
        }
        finally {
            cancellationToken?.remove(cancelAction);
            cancelAction = null;
        }
        return ret;
    }
    /**
     * 取消上一个等待
     * @param type
     */
    cancelLastWait(type) {
        if (!this.tcss.has(type)) {
            return;
        }
        coreWarn(`上一个wait已经取消`, type.name);
        let obj = type.create();
        obj.error = WaitError.Cancel;
        this.notify(obj);
    }
    /**
     * 超时取消等待
     * @param type
     * @param time
     * @param cancellationToken
     * @returns
     */
    async timeoutRun(type, time, cancellationToken) {
        await TimerMgr.getInst().waitAsync(time, cancellationToken);
        if (cancellationToken?.isCancel()) {
            return;
        }
        // 已经执行完毕 不需要执行超时的逻辑
        if (!this.tcss.has(type)) {
            return;
        }
        let obj = type.create();
        obj.error = WaitError.Timeout;
        this.notify(obj);
    }
    notify(obj) {
        let tcs = this.tcss.get(obj.constructor);
        if (!tcs) {
            return;
        }
        this.tcss.delete(obj.constructor);
        tcs.setResult(obj);
        obj.dispose();
    }
}

class CoroutineLockItem {
    init(key) {
        this.key = key;
        this.task = Task.create();
        // 开发阶段进行检查 一分钟还没解锁一般都是bug了
        {
            this._timerId2 = TimerMgr.getInst().newOnceTimer(60 * 1000, this.timeout.bind(this));
            this._timeoutInfo = '60秒没有解锁 出大问题了';
        }
    }
    /**
     *
     * @param timeout 用于开发阶段 多久没解锁就打印警告
     * @param info
     * @returns
     */
    setTimeoutInfo(timeout, info) {
        {
            if (this._timerId1) {
                coreError(`CoroutineLockItem repeat setTimeoutInfo`);
                return;
            }
            this._timerId1 = TimerMgr.getInst().newOnceTimer(timeout, this.timeout.bind(this));
            this._timeoutInfo = info;
        }
    }
    async timeout() {
        {
            coreWarn(`CoroutineLockItem timeout key: ${this.key}`);
            coreWarn(`CoroutineLockItem timeout info: ${this._timeoutInfo}`);
        }
    }
    dispose() {
        {
            if (this._timerId1) {
                TimerMgr.getInst().remove(this._timerId1);
                this._timerId1 = null;
            }
            TimerMgr.getInst().remove(this._timerId2);
            this._timerId2 = null;
            this._timeoutInfo = null;
            if (this.key == null) {
                coreError(`CoroutineLockItem repeat dispose`);
                return;
            }
        }
        CoroutineLock.getInst().runNextLock(this);
        this.key = null;
        this.task = null;
    }
}
class CoroutineLock extends Singleton {
    constructor() {
        super(...arguments);
        this.lockMap = new Map;
    }
    async wait(lockType, key) {
        let newKey = `${lockType}_${key}`;
        let lockSet = this.lockMap.get(newKey);
        if (!lockSet) {
            lockSet = new Set;
            this.lockMap.set(newKey, lockSet);
        }
        let lock = ObjectPool.getInst().fetch(CoroutineLockItem);
        lock.init(newKey);
        lockSet.add(lock);
        if (lockSet.size > 1) {
            await lock.task;
        }
        else {
            lock.task.setResult();
        }
        return lock;
    }
    runNextLock(lock) {
        let lockSet = this.lockMap.get(lock.key);
        lockSet.delete(lock);
        ObjectPool.getInst().recycle(lock);
        for (const nextLock of Array.from(lockSet.values())) {
            nextLock.task.setResult();
            break;
        }
    }
}

class ErrorCore {
    static IsRpcNeedThrowException(error) {
        if (error == null) {
            return false;
        }
        if (error == 0) {
            return false;
        }
        if (error >= ErrorCore.ERR_Exception) {
            return false;
        }
        return true;
    }
}
ErrorCore.ERR_Success = 0;
// static readonly ERR_WChannelReadError = 1;
ErrorCore.ERR_SendMessageNotFoundWChannel = 2;
ErrorCore.ERR_RpcFail = 3;
ErrorCore.ERR_SessionSendOrRecvTimeout = 5;
ErrorCore.ERR_NotFoundActor = 6;
ErrorCore.ERR_ActorTimeout = 7;
ErrorCore.ERR_SessionDisposed = 8;
ErrorCore.ERR_ActorIdIsZero = 9;
ErrorCore.ERR_ActorLocationSenderDispose = 10;
ErrorCore.ERR_ActorLocationError = 11;
ErrorCore.ERR_SessionNotExist = 12;
ErrorCore.ERR_DBErr = 13;
// 小于这个Rpc会抛异常，大于这个异常的error需要自己判断处理，也就是说需要处理的错误应该要大于该值
ErrorCore.ERR_Exception = 1000;
// 下面是框架业务层用到的错误码 1100-2000
/**
 * 账号密码错误
 */
ErrorCore.Login_PasswordError = 1101;
/**
 * 连接gate的key错误
 */
ErrorCore.ERR_ConnectGateKeyError = 1102;
/**
 * 重复发送登录请求
 */
ErrorCore.Login_RepeatRequestGate = 1103;
/**
 * 连接realm失败
 */
ErrorCore.Login_ConnectRealmFailed = 1104;
ErrorCore.Login_ConnectGateFailed = 1105;
/**
 * 账号不存在
 */
ErrorCore.Login_AccountNotExist = 1106;
ErrorCore.Login_UnitNotExist = 1107;

/**
 * rpc消息清理的时候用, 用以传递错误码
 */
class ActorResponse {
    constructor(error) {
        this.error = error;
    }
}

class RpcInfo {
    constructor(request) {
        this.Request = request;
        this.Tcs = Task.create();
    }
    setResult(val) {
        this.Tcs.setResult(val);
        this.Tcs = null;
    }
}
/**
 * session的id跟channel的id是一样的
 */
class Session extends Entity {
    constructor() {
        super(...arguments);
        this.requestCallbacks = new Map;
        this.Error = 0;
    }
    init(serviceId) {
        this.ServiceId = serviceId;
        let timeNow = TimeHelper.clientNow();
        this.LastRecvTime = timeNow;
        this.LastSendTime = timeNow;
    }
    OnResponse(response) {
        let action = this.requestCallbacks.get(response.rpcId);
        if (action == null) {
            throw new Error(`Session OnResponse 没有找到对应的action=${response.rpcId}`);
        }
        this.requestCallbacks.delete(response.rpcId);
        if (ErrorCore.IsRpcNeedThrowException(response.error)) {
            action.setResult(response);
            throw new Error(`Session OnResponse error, req=${action.Request.constructor.name}, ${response.error}`);
        }
        action.setResult(response);
    }
    Send(message) {
        if (this.isDisposed) {
            coreLog('session已经销毁,不能发送消息, message={0}, sessionId={1}', message.constructor.name, this.id);
            return;
        }
        this.SendWithId(0, message);
    }
    SendWithId(actorId, message) {
        if (this.isDisposed) {
            coreLog('session已经销毁,不能发送消息, message={0}, sessionId={1}', message.constructor.name, this.id);
            return;
        }
        this.LastSendTime = TimeHelper.clientNow();
        NetServices.getInst().SendMessage(this.ServiceId, this.id, actorId, message);
    }
    async Call(request) {
        if (this.isDisposed) {
            coreLog('session已经销毁,不能发送消息, message={0}, sessionId={1}', request.constructor.name, this.id);
            let response = new ActorResponse(ErrorCore.ERR_SessionDisposed);
            return response;
        }
        let rpcId = ++Session.RpcId;
        let rpcInfo = new RpcInfo(request);
        this.requestCallbacks.set(rpcId, rpcInfo);
        request.rpcId = rpcId;
        this.Send(request);
        let result = await rpcInfo.Tcs;
        return result;
    }
    destroy() {
        if (this.Error > 0) {
            NetServices.getInst().OnError(this.ServiceId, this.id, this.Error);
        }
        NetServices.getInst().RemoveChannel(this.ServiceId, this.id, this.Error);
        let response = new ActorResponse(ErrorCore.ERR_SessionDisposed);
        for (let [_, responseCallback] of this.requestCallbacks) {
            responseCallback.setResult(response);
        }
        {
            if (!Options.getInst().isServer) {
                coreLog(`session destroy id=${this.id}`);
            }
        }
    }
}
Session.RpcId = 0;

/**
 * 需要存数据库的类 不需要查询的
 */
function DB(constructor) {
    DecoratorCollector.inst.add(DecoratorTypeCore.DB, constructor);
}

/**
 * 事件基类
 */
class AEvent extends RecycleObj {
}

class EntryEvent extends AEvent {
}
class NumericChange extends AEvent {
}
class NetErrorEvent extends AEvent {
}

var InstanceQueueIndex;
(function (InstanceQueueIndex) {
    InstanceQueueIndex[InstanceQueueIndex["None"] = -1] = "None";
    InstanceQueueIndex[InstanceQueueIndex["Update"] = 0] = "Update";
    InstanceQueueIndex[InstanceQueueIndex["LateUpdate"] = 1] = "LateUpdate";
    InstanceQueueIndex[InstanceQueueIndex["Max"] = 2] = "Max";
})(InstanceQueueIndex || (InstanceQueueIndex = {}));

/**
 * 注册实体上的事件系统接口
 */
class EntityIEventSystemLoader {
    static run(iSys) {
        Entity.IEventSystem = iSys;
    }
}

class EventInfo {
    constructor(handler, sceneType) {
        this.eventHandler = handler;
        this.sceneType = sceneType;
    }
}
class EventSystem extends Singleton {
    constructor() {
        super(...arguments);
        this.allEvents = new Map;
        this.queues = new Array(InstanceQueueIndex.Max);
    }
    awake() {
        EntityIEventSystemLoader.run(this);
        for (let i = 0; i < this.queues.length; i++) {
            this.queues[i] = new Array;
        }
        this.initEvent();
    }
    initEvent() {
        let argsList = DecoratorCollector.inst.get(DecoratorTypeCore.Event);
        for (const args of argsList) {
            let eventTypeCtor = args[0];
            let handlerCtor = args[1];
            let sceneType = args[2];
            let list = this.allEvents.get(eventTypeCtor);
            if (!list) {
                list = new Array;
                this.allEvents.set(eventTypeCtor, list);
            }
            list.push(new EventInfo(new handlerCtor(), sceneType));
        }
    }
    registerSystem(component) {
        if (component.update) {
            this.queues[InstanceQueueIndex.Update].push(component.instanceId);
        }
        if (component.lateUpdate) {
            this.queues[InstanceQueueIndex.LateUpdate].push(component.instanceId);
        }
    }
    async publishAsync(scene, eventType) {
        if (!scene) {
            coreError(`发送事件必须传scene`);
        }
        let list = this.allEvents.get(eventType.constructor);
        if (!list) {
            return;
        }
        let tasks = [];
        for (let i = 0; i < list.length; i++) {
            let eventInfo = list[i];
            if (eventInfo.sceneType != scene.sceneType && eventInfo.sceneType != SceneTypeCore$1.None) {
                continue;
            }
            tasks.push(eventInfo.eventHandler.handleAsync(scene, eventType));
        }
        await Promise.all(tasks);
        eventType.dispose();
    }
    /**
     * 一定要确保事件处理函数不是异步方法
     * 否则会导致事件处理顺序不一致和错误无法捕获
     * @param scene
     * @param eventType
     * @returns
     */
    publish(scene, eventType) {
        if (!scene) {
            coreError(`发送事件必须传scene`);
        }
        let list = this.allEvents.get(eventType.constructor);
        if (!list) {
            return;
        }
        for (let i = 0; i < list.length; i++) {
            let eventInfo = list[i];
            if (eventInfo.sceneType != scene.sceneType && eventInfo.sceneType != SceneTypeCore$1.None) {
                continue;
            }
            eventInfo.eventHandler.handle(scene, eventType);
        }
        eventType.dispose();
    }
    awakeComEvent(component) {
        component.awake();
    }
    destroyComEvent(component) {
        component.destroy();
    }
    update() {
        let queue = this.queues[InstanceQueueIndex.Update];
        for (let i = queue.length - 1; i >= 0; i--) {
            let instanceId = queue[i];
            let component = Root.getInst().get(instanceId);
            if (!component) {
                queue.splice(i, 1);
                continue;
            }
            if (component.isDisposed) {
                queue.splice(i, 1);
                continue;
            }
            component.update();
        }
    }
    lateUpdate() {
        let queue = this.queues[InstanceQueueIndex.LateUpdate];
        for (let i = queue.length - 1; i >= 0; i--) {
            let instanceId = queue[i];
            let component = Root.getInst().get(instanceId);
            if (!component) {
                queue.splice(i, 1);
                continue;
            }
            if (component.isDisposed) {
                queue.splice(i, 1);
                continue;
            }
            component.lateUpdate();
        }
    }
}

var __decorate$u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * 数值组件
 */
let NumericComponent = class NumericComponent extends Entity {
    constructor() {
        super(...arguments);
        this.NumericDic = new Map();
    }
    add(nt, value) {
        let oldValue = this.get(nt);
        this.set(nt, oldValue + value);
    }
    addNoEvent(nt, value) {
        let oldValue = this.get(nt);
        this.set(nt, oldValue + value, false);
    }
    sub(nt, value) {
        let oldValue = this.get(nt);
        this.set(nt, oldValue - value);
    }
    subNoEvent(nt, value) {
        let oldValue = this.get(nt);
        this.set(nt, oldValue - value, false);
    }
    set(nt, value, isPublicEvent = true) {
        let oldValue = this.get(nt);
        if (oldValue == value) {
            return;
        }
        this.NumericDic.set(nt, value);
        if (isPublicEvent) {
            EventSystem.getInst().publish(this.domainScene(), NumericChange.create({
                entity: this.parent,
                new: value,
                old: oldValue,
                numericType: nt
            }));
        }
    }
    setNoEvent(nt, value) {
        this.set(nt, value, false);
    }
    get(nt) {
        return this.NumericDic.get(nt) || 0;
    }
    updateKey(numericType, isPublicEvent = true) {
        if (numericType < 1000) {
            return;
        }
        let final = Math.floor(numericType / 10);
        let bas = final * 10 + 1;
        let add = final * 10 + 2;
        let pct = final * 10 + 3;
        let finalAdd = final * 10 + 4;
        let finalPct = final * 10 + 5;
        let finalValue = ((this.get(bas) + this.get(add)) * (100 + this.get(pct)) / 100 + this.get(finalAdd)) * (100 + this.get(finalPct)) / 100;
        finalValue = Math.floor(finalValue);
        this.set(final, finalValue, isPublicEvent);
    }
    resetBase(numericType) {
        let final = Math.floor(numericType / 10);
        let bas = final * 10 + 1;
        let add = final * 10 + 2;
        let pct = final * 10 + 3;
        let finalAdd = final * 10 + 4;
        let finalPct = final * 10 + 5;
        this.NumericDic.delete(bas);
        this.NumericDic.delete(add);
        this.NumericDic.delete(pct);
        this.NumericDic.delete(finalAdd);
        this.NumericDic.delete(finalPct);
    }
};
NumericComponent = __decorate$u([
    DB
], NumericComponent);

/**
 * 监听数值变化
 * @param entityType 实体类型
 * @param type 数值类型
 * @returns
 */
function NumericWatcherHandlerDecorator(entityType, type) {
    return function (target) {
        DecoratorCollector.inst.add(DecoratorTypeCore.NumericWatcher, target, entityType, type);
    };
}

/**
 * 随机数生成器
 */
class RandomGenerator {
    /**
     * 随机整数 [min, max]
     * @param min
     * @param max
     * @returns
     */
    static RandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    /**
     * 万分比是否触发
     * @param prob
     * @returns
     */
    static isTrigger10000Prob(prob) {
        let randNum = this.RandomInt(0, 10000);
        if (randNum <= prob) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * 百分比是否触发
     * @param prob
     * @returns
     */
    static isTrigger100Prob(prob) {
        let randNum = this.RandomInt(0, 100);
        if (randNum <= prob) {
            return true;
        }
        else {
            return false;
        }
    }
}

/**
 * 消息解析管理类 可以通过opcode获取对应的解析器
 */
class MessageParserMgr extends Singleton {
    constructor() {
        super(...arguments);
        this.parsers = new Map();
    }
    awake() {
        let args = DecoratorCollector.inst.get(DecoratorTypeCore.MessageParser);
        for (let arg of args) {
            let type = arg[0];
            let opcode = arg[1];
            this.parsers.set(opcode, type);
        }
    }
    getParser(opcode) {
        let parser = this.parsers.get(opcode);
        if (parser == null) {
            coreError(`找不到opcode:${opcode}对应的解析器`);
        }
        return parser;
    }
}

/**
 * 消息解析器装饰器
 * @param opcode
 * @param messageType
 * @returns
 */
function MessageParserDecorator(opcode) {
    return function (target) {
        DecoratorCollector.inst.add(DecoratorTypeCore.MessageParser, target, opcode);
    };
}

/**
 * 装饰消息
 * @param opcode
 * @param messageType
 * @returns
 */
function MessageDecorator(opcode, messageType) {
    return function (target) {
        DecoratorCollector.inst.add(DecoratorTypeCore.Message, target, messageType, opcode);
    };
}

function ResponseTypeDecorator(responseType) {
    return function (target) {
        DecoratorCollector.inst.add(DecoratorTypeCore.MessageResponse, target, responseType);
    };
}

/**
 * 用来取消某些异步的东西
 */
class CancellationToken {
    constructor() {
        this._actions = new Set();
    }
    /**
     *
     * @param callback 添加取消动作
     * @returns
     */
    add(callback) {
        if (callback == null) {
            coreError(`CancellationToken add error, callback is null`);
            return;
        }
        // 如果action是null，绝对不能添加,要抛异常，说明有协程泄漏
        this._actions.add(callback);
    }
    remove(callback) {
        this._actions.delete(callback);
    }
    /**
     * 执行取消动作
     * @returns
     */
    cancel() {
        if (this._actions == null) {
            coreError(`CancellationToken cancel error, repeat cancel`);
            return;
        }
        this.invoke();
    }
    isCancel() {
        return this._actions == null;
    }
    invoke() {
        let runActions = this._actions;
        this._actions = null;
        try {
            for (let action of runActions) {
                action();
            }
            runActions.clear();
        }
        catch (e) {
            coreError(e);
        }
    }
}

/**
 * key对应value数组的map
 */
class MultiMap {
    constructor() {
        this.Empty = [];
        this.map = new Map();
    }
    add(t, k) {
        let list = this.map.get(t);
        if (list === undefined) {
            list = [];
            this.map.set(t, list);
        }
        list.push(k);
    }
    remove(t, k) {
        const list = this.map.get(t);
        if (list === undefined) {
            return false;
        }
        const index = list.indexOf(k);
        if (index === -1) {
            return false;
        }
        list.splice(index, 1);
        if (list.length === 0) {
            this.map.delete(t);
        }
        return true;
    }
    getAll(t) {
        const list = this.map.get(t);
        if (list === undefined) {
            return [];
        }
        return list;
    }
    get(t) {
        return this.map.get(t) ?? this.Empty;
    }
    getOne(t) {
        const list = this.map.get(t);
        if (list !== undefined && list.length > 0) {
            return list[0];
        }
        return undefined;
    }
    contains(t, k) {
        const list = this.map.get(t);
        if (list === undefined) {
            return false;
        }
        return list.includes(k);
    }
}

class IPEndPoint {
    constructor(host, port = 0) {
        if (port == 0) {
            let strs = host.split(":");
            this.host = strs[0];
            this.port = parseInt(strs[1]);
        }
        else {
            this.host = host;
            this.port = port;
        }
    }
    toString() {
        return `${this.host}:${this.port}`;
    }
}

class AEventHandler {
    async handleAsync(scene, a) {
        try {
            await this.run(scene, a);
        }
        catch (e) {
            if (e instanceof Error) {
                coreError(e.stack);
            }
            else {
                coreError(e);
            }
        }
    }
    handle(scene, a) {
        try {
            let ret = this.run(scene, a);
            if (ret instanceof Promise) {
                coreWarn('{0}的run方法是异步的, 请尽量不要用publish来通知', this.constructor.name);
                safeCall(ret);
            }
        }
        catch (e) {
            if (e instanceof Error) {
                coreError(e.stack);
            }
            else {
                coreError(e);
            }
        }
    }
}
/**
 * 事件装饰器
 * @param eventCls
 * @param sceneType
 * @returns
 */
function EventHandlerDecorator(eventCls, sceneType) {
    return function (target) {
        {
            if (sceneType == null) {
                console.error(`EventDecorator必须要传 sceneType`);
            }
        }
        DecoratorCollector.inst.add(DecoratorTypeCore.Event, eventCls, target, sceneType);
    };
}

class AInvoke {
    static create(values) {
        let event = ObjectPool.getInst().fetch(this);
        if (values) {
            Object.assign(event, values);
        }
        return event;
    }
    dispose() {
        ObjectPool.getInst().recycle(this);
    }
}

/**
 * 帧结束后的动作管理器
 * 比如在帧结束后，执行某些动作
 */
class FrameFinishActionMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._actionMap = new Map();
    }
    getAction(actionType) {
        let action = this._actionMap.get(actionType);
        if (!action) {
            action = ObjectPool.getInst().fetch(actionType);
            action.awake();
            this._actionMap.set(actionType, action);
        }
        return action;
    }
    lateUpdate() {
        if (this._actionMap.size == 0) {
            return;
        }
        let objectPool = ObjectPool.getInst();
        for (let action of this._actionMap.values()) {
            action.run();
            action.destroy();
            objectPool.recycle(action);
        }
        this._actionMap.clear();
    }
}

class EventItem {
}
/**
 * 在entity销毁的时候自动取消订阅
 */
class EventAutoReleaseCom extends Entity {
    constructor() {
        super(...arguments);
        this.events = [];
    }
    addItem(item) {
        this.events.push(item);
    }
    destroy() {
        let eventMap = this.eventCom.eventMap;
        for (let item of this.events) {
            let eventSet = eventMap.get(item.eventCode);
            eventSet.delete(item);
            item.entity = null;
            item.handler = null;
            item.eventCode = null;
            ObjectPool.getInst().recycle(item);
        }
        this.events = [];
    }
}
/**
 * 事件组件 可以发送事件给监听的对象
 * 不允许取消订阅
 */
class EventComponent extends Entity {
    constructor() {
        super(...arguments);
        this.eventMap = new Map;
    }
    /**
     * handler不需要绑定entity 也就是不需要bind
     * @param eventType
     * @param handler
     * @param entity
     */
    subscribe(eventCode, handler, entity) {
        let objectPool = ObjectPool.getInst();
        let item = objectPool.fetch(EventItem);
        item.entity = entity;
        item.handler = handler;
        item.eventCode = eventCode;
        let eventSet = this.eventMap.get(eventCode);
        if (!eventSet) {
            eventSet = new Set();
            this.eventMap.set(eventCode, eventSet);
        }
        eventSet.add(item);
        let autoReleaseCom = entity.getComponent(EventAutoReleaseCom);
        if (!autoReleaseCom) {
            autoReleaseCom = entity.addComponent(EventAutoReleaseCom);
            autoReleaseCom.eventCom = this;
        }
        autoReleaseCom.addItem(item);
    }
    publish(eventCode, ...args) {
        let eventSet = this.eventMap.get(eventCode);
        if (eventSet) {
            for (let item of eventSet) {
                item.handler.apply(item.entity, args);
            }
        }
    }
}

/**
 * 需要存数据库的类 且需要查询的
 * @param key 查询的字段
 * @param isNumberKey 是否是数字key 如果不是就是字符串key
 * @param maxCache 最大缓存数量,缓存服缓存该对象的最大数量，如果超出了就会从缓存中删除
 * @returns
 */
function DBWithKey(key, isNumberKey, maxCache) {
    return function (target) {
        DecoratorCollector.inst.add(DecoratorTypeCore.DB, target, key, isNumberKey, maxCache);
    };
}

/**
 * 需要传送的组件添加这个装饰器
 * 注意 child是不会跟着传送的 只能用于组件上
 * 但是使用DB标志的child和组件都可以跟随传送
 * 不要同时使用Transfer和DB标志
 * 因为包含db的必然会跟着传送
 * @returns
 */
function Transfer(constructor) {
    DecoratorCollector.inst.add(DecoratorTypeCore.Transfer, constructor);
}

class TaskQueue extends RecycleObj {
    constructor() {
        super(...arguments);
        this._queue = [];
        this._running = false;
        this._expireTime = 0;
    }
    get expireTime() {
        return this._expireTime;
    }
    get isRunning() {
        return this._running;
    }
    /**
     * 传入一个方法, 会按顺序执行
     * @param func
     * @example add(()=>console.log('hello'))
     */
    add(func) {
        this._queue.push(func);
        if (this._queue.length === 1) {
            this.run();
        }
    }
    /**
     * 清空所有的任务
     */
    clear() {
        this._queue = [];
    }
    async run() {
        if (this._running) {
            coreError('为什么会出现复入的情况呢, 好奇怪');
            return;
        }
        this._running = true;
        while (this._queue.length > 0) {
            let func = this._queue[0];
            try {
                await func();
            }
            catch (e) {
                coreError('TaskQueue.run error, id={0}, {1}', this.id, e.stack);
            }
            this._queue.shift();
        }
        this._running = false;
        this._expireTime = TimeHelper.clientNow() + 10 * 1000;
    }
}

/**
 * 任务队列
 * 可以让异步任务按顺序执行
 */
class TaskQueueMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._taskQueueMap = new Map();
    }
    awake() {
        TimerMgr.getInst().newRepeatedTimer(10 * 1000, this.checkExpire.bind(this));
    }
    /**
     * 通过标识符获取任务队列
     * 如果不存在则创建一个
     * @param id
     * @returns
     */
    get(id) {
        let taskQueue = this._taskQueueMap.get(id);
        if (!taskQueue) {
            taskQueue = TaskQueue.create();
            taskQueue.id = id;
            coreLog('taskQueue {0} has been created', id);
            this._taskQueueMap.set(id, taskQueue);
        }
        return taskQueue;
    }
    checkExpire() {
        let now = TimeHelper.clientNow();
        let expireList = [];
        for (let [id, taskQueue] of this._taskQueueMap) {
            if (taskQueue.isRunning) {
                continue;
            }
            // 回收过期的任务队列
            if (taskQueue.expireTime < now) {
                expireList.push(id);
                taskQueue.dispose();
                coreLog('taskQueue {0} has been disposed', id);
            }
        }
        for (let id of expireList) {
            this._taskQueueMap.delete(id);
        }
    }
}

/**
 * 回调管理器
 */
class InvokeMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._invokes = new Map;
    }
    awake() {
        let argsList = DecoratorCollector.inst.get(DecoratorTypeCore.Invoke);
        for (const args of argsList) {
            let handlerType = args[0];
            let invokeType = args[1];
            let invokeHandler = new handlerType();
            if (this._invokes.has(invokeType)) {
                console.error(`1个invoketype只能有一个回调, invoketype=${invokeType}`);
            }
            this._invokes.set(invokeType, invokeHandler);
        }
    }
    invoke(type, args) {
        let invokeHandlers = this.getHandler(type);
        return invokeHandlers.handle(args);
    }
    async invokeAsync(type, args) {
        let invokeHandlers = this.getHandler(type);
        return await invokeHandlers.handle(args);
    }
    getHandler(type) {
        let invokeHandler = this._invokes.get(type);
        {
            if (invokeHandler == null) {
                coreError(`未找到对应的invoke: ${type}`);
            }
        }
        return invokeHandler;
    }
}

class AInvokeHandler {
}

/**
 * 回调装饰器
 * @param invokeType
 * @returns
 */
function InvokeDecorator(invokeType) {
    return function (target) {
        DecoratorCollector.inst.add(DecoratorTypeCore.Invoke, target, invokeType);
    };
}

class Injector {
    constructor() {
        this._map = new Map;
    }
    static get inst() {
        if (!this._inst) {
            this._inst = new Injector();
        }
        return this._inst;
    }
    addField(type, target, key) {
        let list = this._map.get(type);
        if (!list) {
            list = [];
            this._map.set(type, list);
        }
        list.push({ target, key });
    }
    staticField(type, inst) {
        let list = this._map.get(type);
        {
            if (!list) {
                console.error(`StaticFieldDecorator: ${type} not found`);
            }
        }
        for (const info of list) {
            info.target[info.key] = inst;
        }
    }
}

/**
 * 静态字段注入装饰器
 * @param type
 * @returns
 */
function InjectorDecorator(type) {
    return function (target, key) {
        Injector.inst.addField(type, target, key);
    };
}

/**
 * 机器管理
 * 在Program.start()之前注册
 * 比如你需要部署在多台机器 那就需要在这里注册
 */
class MachineMgr extends Singleton {
    constructor() {
        super(...arguments);
        /**
         * key是machine id
         */
        this._machineMap = new Map();
    }
    init(cfgs) {
        this._machines = cfgs;
    }
    isInit() {
        return this._machines != null && this._machines.length > 0;
    }
    /**
     * 在配置都加载完成后进行一些初始化操作
     */
    start() {
        for (let i = 0; i < this._machines.length; i++) {
            let cfg = this._machines[i];
            this._machineMap.set(cfg.id, cfg);
        }
    }
    getMachineCfg(machineId) {
        return this._machineMap.get(machineId);
    }
}

class InstanceIdHelper {
    static getSceneInstanceId(processId, sceneId) {
        let objectPool = ObjectPool.getInst();
        let instanceIdStruct = objectPool.fetch(InstanceIdStruct);
        instanceIdStruct.initArgs2(processId, sceneId);
        let instanceId = instanceIdStruct.ToLong();
        objectPool.recycle(instanceIdStruct);
        return instanceId;
    }
    static getProcessId(actorId) {
        let objectPool = ObjectPool.getInst();
        let instanceIdStruct = objectPool.fetch(InstanceIdStruct);
        instanceIdStruct.initArgs1(actorId);
        let processId = instanceIdStruct.Process;
        objectPool.recycle(instanceIdStruct);
        return processId;
    }
}

/**
 * 进程管理器 请在Program.start之前调用init方法初始化
 * 可以用来获取进程的内网地址(注意: 这里的内网地址是指进程间通信的地址, 不是指内网IP)
 * 一开始就需要初始化，因为后面需要用到
 * 比如你的gate是一个进程 map又是一个进程，那么你需要在一开始的时候就把他们的ip地址和端口号写好，这样他们才能互相通信
 */
class ProcessMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._processInfoMap = new Map();
        /**
         * actorid对应的机器id
         */
        this._actorIdMachineMap = new Map();
        this._processIdMachineMap = new Map();
    }
    /**
     * 最多255个进程
     * @param list 进程信息列表
     */
    init(cfgs) {
        this._processes = cfgs;
    }
    isInit() {
        return this._processes != null && this._processes.length > 0;
    }
    /**
     * 在配置都加载完成后进行一些初始化操作
     */
    start() {
        for (let i = 0; i < this._processes.length; i++) {
            let cfg = this._processes[i];
            let machineCfg = MachineMgr.getInst().getMachineCfg(cfg.machineId);
            let info = {
                id: cfg.id,
                machineId: cfg.machineId,
                innerPort: cfg.innerPort,
                innerIp: machineCfg.innerIp,
                outerIp: machineCfg.outerIp,
                innerAddress: new IPEndPoint(machineCfg.innerIp, cfg.innerPort),
                outerAddress: new IPEndPoint(machineCfg.outerIp, cfg.innerPort),
            };
            this._processInfoMap.set(info.id, info);
        }
        let curProcessInfo = this.getCurProcessInfo();
        this._curMachineId = curProcessInfo.machineId;
    }
    getProcessInfo(processId) {
        return this._processInfoMap.get(processId);
    }
    /**
     * 获取当前进程信息
     * @returns
     */
    getCurProcessInfo() {
        return this.getProcessInfo(Options.getInst().process);
    }
    /**
     * 获取当前机器的所有进程信息
     * @returns
     */
    getThisMachineProcessInfos() {
        let infos = [];
        let curProcessInfo = this.getCurProcessInfo();
        for (let info of this._processInfoMap.values()) {
            if (info.machineId == curProcessInfo.machineId) {
                infos.push(info);
            }
        }
        return infos;
    }
    /**
     * 判断某个actorid是否跟当前进程同一机器
     * @param actorId
     */
    actorIdIsInMachine(actorId) {
        let machineId = this._actorIdMachineMap.get(actorId);
        if (machineId == null) {
            let process = InstanceIdHelper.getProcessId(actorId);
            let machineCfg = this.getProcessInfo(process);
            machineId = machineCfg.machineId;
            this._actorIdMachineMap.set(actorId, machineId);
            if (this._actorIdMachineMap.size > 10000) {
                coreWarn(`_actorIdMachineMap.size > 10000: ${this._actorIdMachineMap.size}, 求优化`);
            }
        }
        return machineId == this._curMachineId;
    }
    processIdIsInMachine(processId) {
        let machineId = this._processIdMachineMap.get(processId);
        if (machineId == null) {
            let machineCfg = this.getProcessInfo(processId);
            machineId = machineCfg.machineId;
            this._processIdMachineMap.set(processId, machineId);
        }
        return machineId == this._curMachineId;
    }
}

var AppType;
(function (AppType) {
    /**
     * 启动指定进程
     */
    AppType[AppType["Server"] = 0] = "Server";
    /**
     * 守护进程 用来启动本台机器上的所有进程
     */
    AppType[AppType["Watcher"] = 1] = "Watcher";
    /**
     * 将所有进程合并到一个进程启动
     * 如果有监听外网的端口 要确保不会冲突
     */
    AppType[AppType["AllInOne"] = 2] = "AllInOne";
})(AppType || (AppType = {}));

/**
 * 动态scene自行管理
 * 所有的顶层scene都需要在这里注册 包括不是当前进程的scene
 * 什么是顶层scene呢？就是不会被其他scene包含的scene,比如gate realm
 * 跟ProcessMgr差不多 需要在一开始就注册好
 * scene id是唯一的
 */
class SceneMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._allSceneInfo = [];
        // key是scene id
        this._sceneInfoMap = new Map();
        // key是进程id 同一进程的所有scene
        this._processSceneMap = new MultiMap();
        // key是sceneType 同一类型的所有scene
        this._sceneTypeMap = new MultiMap();
        // key是scene name
        this._sceneNameMap = new Map();
    }
    /**
     * scene配置
     * @param list
     */
    init(cfgs) {
        this._scenes = cfgs;
    }
    isInit() {
        return this._scenes != null && this._scenes.length > 0;
    }
    /**
     * 在配置都加载完成后进行一些初始化操作
     */
    start() {
        let curProcessInfo = ProcessMgr.getInst().getCurProcessInfo();
        for (let i = 0; i < this._scenes.length; i++) {
            let cfg = this._scenes[i];
            let processId = cfg.processId;
            if (Options.getInst().appType == AppType.AllInOne) {
                processId = curProcessInfo.id;
            }
            let instanceId = InstanceIdHelper.getSceneInstanceId(processId, cfg.id);
            let processInfo = ProcessMgr.getInst().getProcessInfo(processId);
            let sceneInfo = {
                id: cfg.id,
                name: cfg.name,
                sceneType: cfg.sceneType,
                processId: processId,
                outerPort: cfg.outerPort,
                dbAddress: cfg.dbAddress,
                dbName: cfg.dbName,
                instanceId: instanceId,
                machineId: processInfo.machineId,
                innerIp: processInfo.innerIp,
                outerIp: processInfo.outerIp,
                dbCacheInterval: cfg.dbCacheInterval,
            };
            if (cfg.outerPort) {
                sceneInfo.outerAddress = new IPEndPoint(processInfo.outerIp, cfg.outerPort);
            }
            this._sceneInfoMap.set(sceneInfo.id, sceneInfo);
            this._processSceneMap.add(sceneInfo.processId, sceneInfo);
            this._sceneTypeMap.add(sceneInfo.sceneType, sceneInfo);
            this._sceneNameMap.set(sceneInfo.name, sceneInfo);
            this._allSceneInfo.push(sceneInfo);
        }
    }
    getSceneCfgs() {
        return this._scenes;
    }
    /**
     * 获取当前进程的所有scene
     * @returns
     */
    curProcessScenes() {
        let currentProcessId = Options.getInst().process;
        return this._processSceneMap.get(currentProcessId);
    }
    /**
     * 获取同类型的第一个scene
     * @param sceneType
     * @returns
     */
    getFirstSceneByType(sceneType) {
        return this.getSceneByType(sceneType)[0];
    }
    /**
     * 获取同类型的所有scene
     * @param sceneType
     * @returns
     */
    getSceneByType(sceneType) {
        return this._sceneTypeMap.get(sceneType);
    }
    getSceneById(sceneId) {
        return this._sceneInfoMap.get(sceneId);
    }
    getSceneByName(sceneName) {
        return this._sceneNameMap.get(sceneName);
    }
}

/**
 * 创建Unit后的事件
 * 可以在这里为Unit添加组件
 */
class AfterCreateUnit extends AEvent {
}
/**
 * 创建GatePlayer后的事件
 * 可以在这里为GatePlayer添加组件
 */
class AfterCreateGatePlayer extends AEvent {
}
/**
 * unit传送之后的处理
 * 这个事件不会等待
 */
class AfterUnitTransfer extends AEvent {
}
class SceneCreateEvent extends AEvent {
}
/**
 * 只有gate可以收到这个事件
 */
class AfterConnectUnit extends AEvent {
}
/**
 * 只有gate可以收到这个事件
 */
class AfterDisconnectUnit extends AEvent {
}

/**
 * 邮箱类型
 */
var MailboxType;
(function (MailboxType) {
    /**
     * 有序
     * 也就是处理消息的时候会队列处理
     * 上一个处理完才会处理下一个
     */
    MailboxType[MailboxType["MessageDispatcher"] = 0] = "MessageDispatcher";
    /**
     * 无序
     */
    MailboxType[MailboxType["UnOrderMessageDispatcher"] = 1] = "UnOrderMessageDispatcher";
    /**
     * 邮箱类型如果是这个的话 收到消息会直接发给客户端
     */
    MailboxType[MailboxType["GateSession"] = 2] = "GateSession";
})(MailboxType || (MailboxType = {}));

class MailBoxQueueItem extends RecycleObj {
}
/**
 * 邮箱组件 挂了这个组件才能接收actor消息
 */
class MailBoxComponent extends Entity {
    constructor() {
        super(...arguments);
        this.reqQueue = [];
        this.isHandling = false;
    }
    awake() {
        this.MailboxType = MailboxType.MessageDispatcher;
    }
    init(mailboxType) {
        this.MailboxType = mailboxType;
    }
    addReq(request, fromProcess) {
        let item = MailBoxQueueItem.create({ fromProcess, req: request });
        this.reqQueue.push(item);
    }
    getReq() {
        return this.reqQueue.shift();
    }
    destroy() {
        this.clearItem();
        this.isHandling = false;
    }
    clearItem() {
        if (this.reqQueue.length == 0) {
            return;
        }
        for (let item of this.reqQueue) {
            item.dispose();
        }
        this.reqQueue = [];
    }
}

var ServiceType;
(function (ServiceType) {
    ServiceType[ServiceType["Outer"] = 0] = "Outer";
    ServiceType[ServiceType["Inner"] = 1] = "Inner";
})(ServiceType || (ServiceType = {}));

class AService {
}

class AChannel {
    get IsDisposed() {
        return this.Id == 0;
    }
}

const r$1 = new pb.Reader(new Uint8Array());
class MessageHelper {
    static getActorId(bytes) {
        r$1.pos = 0;
        r$1.buf = bytes;
        r$1.len = bytes.length;
        r$1.skip();
        r$1.skip();
        const tag = r$1.uint32();
        if (tag >>> 3 == 2) {
            let xx = r$1.uint64();
            return xx.toNumber();
        }
        return 0;
    }
    static getOpcode(bytes) {
        r$1.pos = 0;
        r$1.buf = bytes;
        r$1.len = bytes.length;
        const tag = r$1.uint32();
        if (tag >>> 3 == 1) {
            return r$1.uint32();
        }
        return 0;
    }
}

/**
 * socket关闭码
 * 4001-4999
 */
var SocketCloseCode;
(function (SocketCloseCode) {
    /**
     * 其他设备登录
     */
    SocketCloseCode[SocketCloseCode["OtherLogin"] = 4001] = "OtherLogin";
    /**
     * 一般是发送过来的消息解析错误
     */
    SocketCloseCode[SocketCloseCode["WChannelReadError"] = 4002] = "WChannelReadError";
    SocketCloseCode[SocketCloseCode["WebSocketError"] = 4003] = "WebSocketError";
    SocketCloseCode[SocketCloseCode["ServerMaxLimit"] = 4004] = "ServerMaxLimit";
})(SocketCloseCode || (SocketCloseCode = {}));

// import Long from 'long';
// 服务端不需要
// pb.util.Long = Long;
// pb.configure();
const r = new pb$1.Reader(new Uint8Array());
const w = new pb$1.Writer();
class WChannel extends AChannel {
    constructor() {
        super();
        this.isConnected = false;
        this.msgQueue = [];
    }
    initBySocket(socket, id, service) {
        this.uSocket = socket;
        this.Id = id;
        this.Service = service;
        this.isConnected = true;
        let remoteAddr = socket.getRemoteAddressAsText();
        let remoteAddrStr = new TextDecoder('utf-8').decode(remoteAddr);
        this.remoteAddress = new IPEndPoint(remoteAddrStr, 1111);
    }
    /**
     * 通过地址建立连接
     * 也就是客户端
     * @param address
     * @param id
     * @param service
     */
    initByAddress(address, id, service) {
        this.wSocket = new WebSocket(`ws://${address}`);
        this.Id = id;
        this.Service = service;
        this.remoteAddress = address;
        // this.addTimeoutTimer();
        this.wSocket.on("message", this.onMessage.bind(this));
        this.wSocket.on("open", this.onConnectComplete.bind(this));
        this.wSocket.on("close", this.onSocketClose.bind(this));
        this.wSocket.on("error", this.onWsSocketError.bind(this));
    }
    connectTimeout() {
        coreLog(`连接超时, address=${this.remoteAddress.toString()}`);
    }
    addTimeoutTimer() {
        if (this._timerId != null) {
            return;
        }
        this._timerId = TimerMgr.getInst().newOnceTimer(3 * 1000, this.connectTimeout.bind(this));
        coreLog(`wchannel添加定时器`);
    }
    removeTimer(tips) {
        if (this._timerId == null) {
            return;
        }
        TimerMgr.getInst().remove(this._timerId);
        this._timerId = null;
        coreLog(`wchannel移除定时器,${tips}, address=${this.remoteAddress.toString()}`);
    }
    onConnectComplete() {
        this.removeTimer('连接成功');
        this.isConnected = true;
        for (const msg of this.msgQueue) {
            this.innerSend(msg);
        }
        this.msgQueue = [];
    }
    onMessage(data, isBinary) {
        try {
            // // 压力测试用 后面记得注释掉
            // if (!isBinary) {
            //     let str = new TextDecoder('utf-8').decode(data);
            //     if (str == "test-pressure") {
            //         let channelId = this.Id;
            //         NetServices.getInst().OnRead(this.Service.Id, channelId, 0, new C2G_TestPressure);
            //     } else {
            //         this.closeSocket(SocketCloseCode.WChannelReadError);
            //     }
            //     return;
            // }
            if (!isBinary) {
                coreError(`WChannel onMessage: data is not binary`);
                this.closeSocket(SocketCloseCode.WChannelReadError);
                return;
            }
            let channelId = this.Id;
            let actorId = 0;
            let opcode = MessageHelper.getOpcode(data);
            let type = NetServices.getInst().GetType(opcode);
            let parser = MessageParserMgr.getInst().getParser(opcode);
            if (type == null) {
                coreError(`opcode=${opcode}找不到对应的构造函数`);
                return;
            }
            let message = new type();
            r.pos = 0;
            r.buf = data;
            r.len = data.length;
            parser.decode(r, message);
            switch (this.Service.ServiceType) {
                case ServiceType.Outer: {
                    // 外网消息(客户端发过来的)不需要携带actorId 直接发到了对应的网关
                    break;
                }
                case ServiceType.Inner: {
                    actorId = MessageHelper.getActorId(data);
                    break;
                }
            }
            MsgPrinter.getInst().log(message, 'on message:');
            NetServices.getInst().OnRead(this.Service.Id, channelId, actorId, message);
        }
        catch (error) {
            coreError('WChannel onMessage, remoteAddress={1} error={0}', error.stack, this.remoteAddress.toString());
            // 出现任何消息解析异常都要断开Session，防止客户端伪造消息
            this.OnError(SocketCloseCode.WChannelReadError);
        }
    }
    Dispose() {
        if (this.IsDisposed) {
            return;
        }
        coreLog(`wchannel dispose, address=${this.remoteAddress.toString()}`);
        this.removeTimer('wchannel dispose');
        this.Id = 0;
        this.uSocket = null;
        this.wSocket = null;
        this.msgQueue = null;
        this.Service = null;
        this.isConnected = false;
        this.remoteAddress = null;
    }
    onWsSocketError(e) {
        coreLog(`onWsSocketError error, ${e.message}`);
        this.onSocketClose(SocketCloseCode.WebSocketError);
    }
    /**
     * socket被动关闭
     * @param code
     */
    onSocketClose(code) {
        if (this.Service) {
            this.Service.channelClose(this, code);
        }
    }
    /**
     * 这里的只能是主动关闭
     */
    closeSocket(code) {
        if (code < 4000) {
            if (this.uSocket != null) {
                this.uSocket.end();
            }
            if (this.wSocket != null) {
                this.wSocket.close();
            }
        }
        else {
            if (this.uSocket != null) {
                this.uSocket.end(code);
            }
            if (this.wSocket != null) {
                this.wSocket.close(code);
            }
        }
    }
    OnError(error) {
        this.Service.Remove(this.Id, error);
    }
    innerSend(raw) {
        if (this.uSocket != null) {
            this.uSocket.send(raw, true);
        }
        else {
            this.wSocket.send(raw);
        }
    }
    Send(actorId, message) {
        if (this.IsDisposed) {
            throw new Error("WChannel已经被Dispose, 不能发送消息");
        }
        MsgPrinter.getInst().log(message, 'send message:');
        let opcode = NetServices.getInst().GetOpcode(message.constructor);
        let parser = MessageParserMgr.getInst().getParser(opcode);
        w.reset();
        w.uint32(8).uint32(opcode);
        switch (this.Service.ServiceType) {
            case ServiceType.Inner: {
                w.uint32(16).uint64(actorId);
                break;
            }
            case ServiceType.Outer: {
                break;
            }
        }
        parser.encode(w, message);
        let result = w.finish();
        if (result.byteLength > 10000) {
            coreWarn(`发送消息长度超过10000字节, 可能是有问题的消息, opcode=${opcode}, name=${message.constructor.name}, length=${result.byteLength}`);
        }
        if (this.isConnected) {
            this.innerSend(result);
        }
        else {
            this.msgQueue.push(result);
        }
    }
}

class WService extends AService {
    constructor() {
        super(...arguments);
        this._idChannels = new Map;
        this._wsChannels = new Map;
    }
    initSender(serviceType) {
        this.ServiceType = serviceType;
    }
    initAcceptor(address, serviceType) {
        this.address = address;
        this.ServiceType = serviceType;
        this.restartAcceptor();
        addExitCallback((signal) => {
            coreLog(`WService exit signal=${signal}`);
            this.closeAcceptor();
        });
    }
    restartAcceptor() {
        this.acceptor = App();
        this.acceptor.ws('/*', {
            open: this.onConnection.bind(this),
            drain: this.onDrain.bind(this),
            close: this.onClose.bind(this),
            message: this.onMessage.bind(this),
            // 单个消息最大长度
            maxPayloadLength: 16 * 1024,
        });
        this.acceptor.listen(this.address.host, this.address.port, (listenSocket) => {
            if (listenSocket) {
                coreLog(`WService listen ${this.address.host}:${this.address.port}`);
            }
            else {
                coreError(`WService listen failed ${this.address.host}:${this.address.port}`);
            }
        });
    }
    /**
     * 关闭监听
     * @returns
     */
    closeAcceptor() {
        if (this.acceptor == null) {
            return;
        }
        coreLog('WService closeAcceptor, address = {0}', this.address.toString());
        this.acceptor = null;
        us_listen_socket_close(this.acceptor);
        for (let [id, channel] of this._idChannels) {
            this.Remove(id);
        }
    }
    Send(channelId, actorId, message) {
        try {
            let aChannel = this._idChannels.get(channelId);
            if (aChannel == null) {
                NetServices.getInst().OnError(this.Id, channelId, ErrorCore.ERR_SendMessageNotFoundWChannel);
                return;
            }
            aChannel.Send(actorId, message);
        }
        catch (e) {
            coreError(e.stack);
        }
    }
    innerCreate(id, address) {
        let channel = new WChannel();
        channel.initByAddress(address, id, this);
        this._idChannels.set(channel.Id, channel);
    }
    Create(id, address) {
        if (this._idChannels.has(id)) {
            return;
        }
        this.innerCreate(id, address);
    }
    Dispose() {
    }
    /**
     * 这里的只能是主动关闭
     * @param id
     * @param error
     */
    Remove(id, error = 0) {
        let channel = this._idChannels.get(id);
        if (!channel) {
            return;
        }
        channel.closeSocket(error);
        this._wsChannels.delete(channel.uSocket);
        this._idChannels.delete(id);
        channel.Dispose();
    }
    /**
     * channel 被动关闭 调用这个
     * @param channel
     * @param code
     */
    channelClose(channel, code) {
        this._idChannels.delete(channel.Id);
        if (channel.uSocket != null) {
            this._wsChannels.delete(channel.uSocket);
        }
        NetServices.getInst().OnError(this.Id, channel.Id, code);
        channel.Dispose();
    }
    onMessage(ws, message, isBinary) {
        let channel = this._wsChannels.get(ws);
        if (channel == null) {
            coreLog(`onMessage: channel == null`);
            return;
        }
        // 这里先屏蔽 后面再开启
        if (!isBinary) {
            this.Remove(channel.Id, SocketCloseCode.WChannelReadError);
            coreError('onMessage: isBinary == false');
            return;
        }
        channel.onMessage(new Uint8Array(message), isBinary);
    }
    onConnection(ws) {
        // 暂时单个服务最多300个连接 如有需要自行修改
        if (this._wsChannels.size > 3000) {
            coreWarn('WService: 连接数过多');
            ws.end(SocketCloseCode.ServerMaxLimit);
            return;
        }
        let id = NetServices.getInst().CreateAcceptChannelId();
        let channel = new WChannel();
        this._wsChannels.set(ws, channel);
        this._idChannels.set(id, channel);
        channel.initBySocket(ws, id, this);
        NetServices.getInst().OnAccept(this.Id, id, channel.remoteAddress);
    }
    onClose(ws, code) {
        let channel = this._wsChannels.get(ws);
        if (channel == null) {
            coreLog(`onClose: channel == null`);
            return;
        }
        channel.onSocketClose(code);
    }
    /**
     * 没搞懂这个是干什么的
     * @param ws
     */
    onDrain(ws) {
        coreLog(`onDrain: 压力过大`);
    }
}

/**
 * 用于处理session验证超时
 * 超时后断开连接
 */
class SessionAcceptTimeoutComponent extends Entity {
    awake() {
        this.Timer = TimerMgr.getInst().newOnceTimer(5 * 1000, this.timerCallback.bind(this));
    }
    timerCallback() {
        this.parent.id;
        this.parent.dispose();
    }
    destroy() {
        TimerMgr.getInst().remove(this.Timer);
        this.Timer = 0;
    }
}

/**
 * 用于检测session长时间不通信的组件
 * 一旦发现长时间不通信就销毁session
 */
class SessionIdleCheckerComponent extends Entity {
    awake() {
        this.RepeatedTimer = TimerMgr.getInst().newRepeatedTimer(SessionIdleCheckerComponent.CheckInteral, this.check.bind(this));
    }
    check() {
        let session = this.getParent(Session);
        let timeNow = TimeHelper.clientNow();
        if (timeNow - session.LastRecvTime < SessionIdleCheckerComponent.SessionTimeoutTime && timeNow - session.LastSendTime < SessionIdleCheckerComponent.SessionTimeoutTime) {
            return;
        }
        session.Error = ErrorCore.ERR_SessionSendOrRecvTimeout;
        session.dispose();
    }
    destroy() {
        TimerMgr.getInst().remove(this.RepeatedTimer);
        this.RepeatedTimer = 0;
    }
}
SessionIdleCheckerComponent.CheckInteral = 2000;
SessionIdleCheckerComponent.SessionTimeoutTime = 15 * 1000;

var DecoratorType;
(function (DecoratorType) {
    DecoratorType["OuterMsgHandler"] = "OuterMsgHandler";
    DecoratorType["InnerMsgHandler"] = "InnerMsgHandler";
    DecoratorType["ActorMessageHandler"] = "ActorMessageHandler";
})(DecoratorType || (DecoratorType = {}));

/**
 * 收到外网来的消息后 根据messageType分发到不同的消息处理器
 */
class OuterMessageMsgDispatcher extends Singleton {
    constructor() {
        super(...arguments);
        this._handlers = new Map();
    }
    awake() {
        let list = DecoratorCollector.inst.get(DecoratorType.OuterMsgHandler);
        for (const args of list) {
            let handlerType = args[0];
            let msgType = args[1];
            let handler = new handlerType();
            this._handlers.set(msgType, handler);
        }
    }
    handle(session, msg) {
        try {
            let messageType = MessageTypeMgr.getInst().getMessageType(msg.constructor);
            // 如果是回应 直接调用session的onResponse
            // 这里可以忽略 因为不会对客户端发起rpc请求
            if (messageType == MessageTypeCore.Response
                || messageType == MessageTypeCore.ActorResponse
                || messageType == MessageTypeCore.ActorLocationResponse) {
                coreWarn('OuterMessageMsgDispatcher.handle ignore response msg, bug got response msg from outer, please check! msg={0}', msg.constructor.name);
                session.OnResponse(msg);
                return;
            }
            let handler = this._handlers.get(messageType);
            if (!handler) {
                throw new Error(`OuterMessageMsgDispatcher handle not found handler ${messageType}`);
            }
            handler.run(session, msg);
        }
        catch (e) {
            coreError('OuterMessageMsgDispatcher.handle error, msg={0}, {1}', msg.constructor.name, e.stack);
        }
    }
}

/**
 * 挂上这个组件 就可以监听外网消息
 */
class NetServerComponent extends Entity {
    init(address) {
        this.delayInit(address);
    }
    /**
     * 延迟初始化 防止在程序启动时候客户端就发了消息
     */
    async delayInit(address) {
        await TimerMgr.getInst().waitAsync(5 * 1000);
        coreLog('[scene {0}], 外网开启监听: {1}', this.domainScene().name, address.toString());
        let service = new WService();
        let netServices = NetServices.getInst();
        service.initAcceptor(address, ServiceType.Outer);
        this.ServiceId = netServices.AddService(service);
        netServices.RegisterAcceptCallback(this.ServiceId, this.OnAccept.bind(this));
        netServices.RegisterReadCallback(this.ServiceId, this.OnRead.bind(this));
        netServices.RegisterErrorCallback(this.ServiceId, this.OnError.bind(this));
    }
    destroy() {
        let netServices = NetServices.getInst();
        netServices.RemoveService(this.ServiceId);
    }
    OnError(channelId, error) {
        let session = this.getChild(Session, channelId);
        if (session == null) {
            return;
        }
        session.Error = error;
        session.dispose();
    }
    // 这个channelId是由CreateAcceptChannelId生成的
    OnAccept(channelId, ipEndPoint) {
        let session = this.addChildWithId(Session, channelId);
        session.init(this.ServiceId);
        session.RemoteAddress = ipEndPoint;
        // session超时未验证，就会被删除
        session.addComponent(SessionAcceptTimeoutComponent);
        // session长时间没有发消息，就会被删除
        session.addComponent(SessionIdleCheckerComponent);
    }
    OnRead(channelId, actorId, message) {
        let session = this.getChild(Session, channelId);
        if (session == null) {
            return;
        }
        session.LastRecvTime = TimeHelper.clientNow();
        OuterMessageMsgDispatcher.getInst().handle(session, message);
    }
}

/**
 * 可以移动顺序的map
 */
class HashList {
    constructor() {
        this._hashTable = {};
        this._head = this._tail = null;
        this._length = 0;
    }
    *iterator() {
        let currentItem = this._head;
        let count = 0;
        while (currentItem) {
            yield currentItem.value;
            currentItem = currentItem.next;
            count++;
            if (count > 1000000) {
                console.error('HashList possible circle loop');
                break;
            }
        }
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    get head() {
        return this._head ? this._head.value : null;
    }
    get tail() {
        return this._tail ? this._tail.value : null;
    }
    get length() {
        return this._length;
    }
    // Adds the element at a specific position inside the linked list
    insert(key, val, previousKey, checkDuplicates = false) {
        if (checkDuplicates && this.isDuplicate(val)) {
            return null;
        }
        if (this._hashTable[key] != null) {
            console.error(`key has exist, key=${key}`);
            return null;
        }
        let newItem = new LinkedListItem(key, val);
        this._hashTable[key] = newItem;
        let previousItem = this._hashTable[previousKey];
        if (!previousItem) {
            return null;
        }
        else {
            newItem.prev = previousItem;
            newItem.next = previousItem.next;
            if (!previousItem.next) {
                this._tail = newItem;
            }
            else {
                previousItem.next.prev = newItem;
            }
            previousItem.next = newItem;
            this._length++;
            return key;
        }
    }
    get(key) {
        let item = this._hashTable[key];
        if (item == null) {
            return;
        }
        return item.value;
    }
    /**
     * 移动到最前面
     * @param key
     * @returns
     */
    moveToHead(key) {
        let currentItem = this._hashTable[key];
        if (currentItem == null) {
            return;
        }
        if (currentItem === this._head) {
            return;
        }
        else if (currentItem === this._tail) {
            this._tail = currentItem.prev;
            this._tail.next = null;
        }
        else {
            currentItem.prev.next = currentItem.next;
            currentItem.next.prev = currentItem.prev;
        }
        this._head.prev = currentItem;
        currentItem.prev = null;
        currentItem.next = this._head;
        this._head = currentItem;
    }
    // Adds the element at the end of the linked list
    append(key, val, checkDuplicates = false) {
        if (checkDuplicates && this.isDuplicate(val)) {
            return null;
        }
        if (this._hashTable[key] != null) {
            console.error(`key has exist, key=${key}`);
            return null;
        }
        let newItem = new LinkedListItem(key, val);
        this._hashTable[key] = newItem;
        if (!this._tail) {
            this._head = this._tail = newItem;
        }
        else {
            newItem.prev = this._tail;
            this._tail.next = newItem;
            this._tail = newItem;
        }
        this._length++;
        return key;
    }
    /**
     * 添加到最前面
     * @param key
     * @param val
     * @param checkDuplicates
     * @returns
     */
    prepend(key, val, checkDuplicates = false) {
        if (checkDuplicates && this.isDuplicate(val)) {
            return null;
        }
        if (this._hashTable[key] != null) {
            console.error(`key has exist, key=${key}`);
            return null;
        }
        let newItem = new LinkedListItem(key, val);
        this._hashTable[key] = newItem;
        if (!this._head) {
            this._head = this._tail = newItem;
        }
        else {
            newItem.next = this._head;
            this._head.prev = newItem;
            this._head = newItem;
        }
        this._length++;
        return key;
    }
    remove(key) {
        let currentItem = this._hashTable[key];
        if (!currentItem) {
            return;
        }
        if (currentItem === this._head) {
            this._head = currentItem.next;
        }
        else if (currentItem === this._tail) {
            this._tail = currentItem.prev;
        }
        else {
            currentItem.prev.next = currentItem.next;
            currentItem.next.prev = currentItem.prev;
        }
        currentItem.next = null;
        currentItem.prev = null;
        delete this._hashTable[key];
        this._length--;
        return currentItem.value;
    }
    removeHead() {
        let currentItem = this._head;
        // empty list
        if (!currentItem) {
            return;
        }
        // single item list
        if (!this._head.next) {
            this._head = null;
            this._tail = null;
            // full list
        }
        else {
            this._head.next.prev = null;
            this._head = this._head.next;
        }
        currentItem.next = currentItem.prev = null;
        delete this._hashTable[currentItem.key];
        this._length--;
        return currentItem.value;
    }
    removeTail() {
        let currentItem = this._tail;
        // empty list
        if (!currentItem) {
            return;
        }
        // single item list
        if (!this._tail.prev) {
            this._head = null;
            this._tail = null;
            // full list
        }
        else {
            this._tail.prev.next = null;
            this._tail = this._tail.prev;
        }
        currentItem.next = currentItem.prev = null;
        delete this._hashTable[currentItem.key];
        this._length--;
        return currentItem.value;
    }
    toArray() {
        return [...this];
    }
    isDuplicate(val) {
        let set = new Set(this.toArray());
        return set.has(val);
    }
}
class LinkedListItem {
    constructor(key, val) {
        this.key = key;
        this.value = val;
        this.next = null;
        this.prev = null;
    }
}

class CacheItem {
    constructor() {
        this.isChange = false;
    }
}

var LockTypeCore;
(function (LockTypeCore) {
    LockTypeCore["Location"] = "Location";
    LockTypeCore["ActorLocationSender"] = "ActorLocationSender";
    LockTypeCore["Mailbox"] = "Mailbox";
    LockTypeCore["DB"] = "DB";
    LockTypeCore["GetGatePlayer"] = "GetGatePlayer";
    LockTypeCore["CheckAccount"] = "CheckAccount";
    LockTypeCore["C2G_LoginGate"] = "C2G_LoginGate";
    LockTypeCore["UnitConnect"] = "UnitConnect";
    LockTypeCore["Transfer"] = "Transfer";
})(LockTypeCore || (LockTypeCore = {}));

/**
 * 主要用于将对象转化成bson,以便于MongoDB存储
 */
class DBSerializeMgr extends Singleton {
    constructor() {
        super(...arguments);
        // 注意避免同名类
        this._name2CtorMap = new Map;
        /**
         * 忽略的key 比如_id 这个是bson存储的时候用的
         */
        this._ignoreKeys = new Set(['_id']);
    }
    awake() {
        let list1 = DecoratorCollector.inst.get(DecoratorTypeCore.Transfer);
        for (const args of list1) {
            let ctor = args[0];
            this._name2CtorMap.set(ctor.name, ctor);
        }
        let list2 = DecoratorCollector.inst.get(DecoratorTypeCore.DB);
        for (const args of list2) {
            let ctor = args[0];
            this._name2CtorMap.set(ctor.name, ctor);
        }
    }
    /**
     * 注册需要序列化的类型 没有注册是不支持序列化的
     * 且一定要注意 序列化的Type构造函数不能有参数
     * @param type
     */
    registerType(type) {
        this._name2CtorMap.set(type.name, type);
    }
    /**
     * 弃用这个方法 效率太低了
     * @param obj
     * @returns
     */
    serializeToUint8Array(obj) {
        let serialized = this.serializeToObject(obj);
        let bson = BSON.serialize(serialized);
        return bson;
    }
    /**
     * 转化成bson可以序列化的对象
     * @param obj
     * @returns
     */
    serializeToObject(obj) {
        if (obj == null) {
            return;
        }
        if (typeof obj != "object") {
            return obj;
        }
        if (obj instanceof Array) {
            let newObj = new Array(obj.length);
            for (let i = 0; i < obj.length; i++) {
                newObj[i] = this.serializeToObject(obj[i]);
            }
            return newObj;
        }
        if (obj instanceof Map) {
            let newObj = {
                ctorName: 'Map',
                keyList: new Array(obj.size),
                valueList: new Array(obj.size),
            };
            let count = 0;
            for (let [key, value] of obj) {
                newObj.keyList[count] = this.serializeToObject(key);
                newObj.valueList[count++] = this.serializeToObject(value);
            }
            return newObj;
        }
        if (obj instanceof Set) {
            let newObj = {
                ctorName: 'Set',
                valueList: new Array(obj.size),
            };
            let count = 0;
            for (let value of obj) {
                newObj.valueList[count++] = this.serializeToObject(value);
            }
            return newObj;
        }
        if (obj.constructor != null) {
            let keys = Object.keys(obj);
            let ctor = obj.constructor;
            let newObj = { ctorName: ctor.name };
            for (const key of keys) {
                if (this._ignoreKeys.has(key)) {
                    continue;
                }
                newObj[key] = this.serializeToObject(obj[key]);
            }
            return newObj;
        }
        return obj;
    }
    deserialize(from) {
        if (from == null) {
            return;
        }
        let obj = from;
        if (from instanceof Uint8Array) {
            obj = BSON.deserialize(from);
        }
        if (obj.ctorName != null) {
            if (obj.ctorName == 'Set') {
                let newObj = new Set();
                for (let i = 0; i < obj.valueList.length; i++) {
                    let value = obj.valueList[i];
                    newObj.add(this.deserialize(value));
                }
                return newObj;
            }
            else if (obj.ctorName == 'Map') {
                let newObj = new Map();
                for (let i = 0; i < obj.valueList.length; i++) {
                    let key = obj.keyList[i];
                    let value = obj.valueList[i];
                    newObj.set(key, this.deserialize(value));
                }
                return newObj;
            }
            let objCtor = this._name2CtorMap.get(obj.ctorName);
            if (!objCtor) {
                coreError(`${obj.ctorName}不能识别的反序列化对象`);
                return;
            }
            let objNew = new objCtor();
            for (let key in obj) {
                if (key == 'ctorName') {
                    continue;
                }
                if (this._ignoreKeys.has(key)) {
                    continue;
                }
                objNew[key] = this.deserialize(obj[key]);
            }
            return objNew;
        }
        if (obj instanceof Array) {
            let newObj = new Array(obj.length);
            for (let i = 0; i < obj.length; i++) {
                let value = obj[i];
                newObj[i] = this.deserialize(value);
            }
            return newObj;
        }
        return obj;
    }
}

/**
 * 数据库组件
 * 用于连接数据库
 * 存取都需要靠这个组件
 * todo 改成单例
 */
class DBComponent extends Entity {
    awake() {
        DBComponent.inst = this;
    }
    destroy() {
        DBComponent.inst = null;
    }
    async init(dbAddress, dbName) {
        this.mongoClient = new MongoClient(dbAddress);
        await this.mongoClient.connect();
        this.database = this.mongoClient.db(dbName);
        coreLog(`数据库连接完成`);
        this.mongoClient.on('close', () => {
            coreError(`数据库连接断开`);
        });
        return this;
    }
    getCollection(name) {
        return this.database.collection(name);
    }
    async query(type, filter) {
        if (this.database == null) {
            return;
        }
        let random = RandomGenerator.RandomInt(1, 10086) % DBComponent.TaskCount;
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.DB, random.toString());
        try {
            let filteredDocs = await this.getCollection(type.name).findOne(filter);
            if (filteredDocs) {
                let time1;
                if (DEVELOP) {
                    time1 = Date.now();
                }
                let cls = DBSerializeMgr.getInst().deserialize(filteredDocs);
                if (DEVELOP) {
                    let cost = Date.now() - time1;
                    if (cost > 1) {
                        coreWarn(`DBComponent deserialize cost time=${cost}ms, 请考虑优化!`);
                    }
                }
                return cls;
            }
        }
        finally {
            lock.dispose();
        }
    }
    async save(classObj, filter) {
        if (this.database == null) {
            return;
        }
        if (!classObj.constructor) {
            coreWarn(`储存的对象必须是class`);
            return;
        }
        let num = RandomGenerator.RandomInt(1, 10086);
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.DB, (num % DBComponent.TaskCount).toString());
        try {
            let time1;
            if (DEVELOP) {
                time1 = Date.now();
            }
            // 先转化成普通的object
            let normalObj = DBSerializeMgr.getInst().serializeToObject(classObj);
            if (DEVELOP) {
                let cost = Date.now() - time1;
                if (cost > 1) {
                    coreWarn(`DBComponent serialize cost time=${cost}ms, 请考虑优化!`);
                }
            }
            coreLog('DBComponent save obj={0}', JSON.stringify(normalObj));
            await this.getCollection(classObj.constructor.name).replaceOne(filter, normalObj, { upsert: true });
        }
        finally {
            lock.dispose();
        }
    }
    async remove(type, filter) {
        if (this.database == null) {
            return;
        }
        let num = RandomGenerator.RandomInt(1, 10086);
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.DB, (num % DBComponent.TaskCount).toString());
        try {
            await this.getCollection(type.name).deleteOne(filter);
        }
        finally {
            lock.dispose();
        }
    }
}
DBComponent.TaskCount = 32;

class DBCacheComponent extends Entity {
    constructor() {
        super(...arguments);
        this.cacheList = new HashList();
    }
    init(config) {
        this._config = config;
        this._filter = {};
        return this;
    }
    async saveToDB() {
        let dbNotExist = DBComponent.inst == null;
        if (dbNotExist) {
            return;
        }
        let list = this.cacheList;
        for (let item of list) {
            if (!item.isChange) {
                continue;
            }
            item.isChange = false;
            this._filter[this._config.key] = item.data[this._config.key];
            await DBComponent.inst.save(item.data, this._filter);
        }
        // if (DEVELOP) {
        //     coreLog(`[DBCacheComponent] cache ${this._config.type.name}, change=${changeCount}, list=${list.length}`)
        // }
        let cacheDropNum = list.length - this._config.maxCache;
        for (let i = 0; i < cacheDropNum; i++) {
            list.removeTail();
        }
    }
    async query(value) {
        let cacheList = this.cacheList;
        let cacheItem = cacheList.get(value);
        let data;
        if (cacheItem == null) {
            let dbNotExist = DBComponent.inst == null;
            if (dbNotExist) {
                return;
            }
            this._filter[this._config.key] = value;
            data = await DBComponent.inst?.query(this._config.type, this._filter);
            if (data == null) {
                return;
            }
            cacheItem = new CacheItem();
            cacheItem.data = data;
            cacheList.prepend(value, cacheItem);
        }
        else {
            cacheList.moveToHead(value);
            data = cacheItem.data;
        }
        return data;
    }
    /**
     * 这是一个class的实例
     * @param data
     */
    save(data) {
        let cacheList = this.cacheList;
        let key = data[this._config.key];
        let cacheItem = cacheList.get(key);
        if (cacheItem == null) {
            cacheItem = new CacheItem();
            cacheList.prepend(key, cacheItem);
        }
        else {
            cacheList.moveToHead(key);
        }
        cacheItem.data = data;
        cacheItem.isChange = true;
    }
    async delete(value) {
        let cacheList = this.cacheList;
        let cacheItem = cacheList.get(value);
        if (cacheItem != null) {
            cacheList.remove(value);
        }
        this._filter[this._config.key] = value;
        await DBComponent.inst.remove(this._config.type, this._filter);
    }
}

class DBCacheComponentMgr extends Entity {
    constructor() {
        super(...arguments);
        this._cacheList = [];
        this._type2ComMap = new Map();
    }
    awake() {
        let list = DecoratorCollector.inst.get(DecoratorTypeCore.DB);
        for (const args of list) {
            // 不需要查询的类型不处理
            if (args.length == 1) {
                continue;
            }
            let type = args[0];
            let key = args[1];
            let isNumberKey = args[2];
            let maxCache = args[3];
            let cacheCom = this.addChild(DBCacheComponent).init({
                isNumberKey: isNumberKey,
                key: key,
                maxCache: maxCache,
                type: type,
            });
            this._cacheList.push(cacheCom);
            this._type2ComMap.set(type, cacheCom);
        }
    }
    /**
     * 缓存间隔时间
     * 也就是多长时间存一次数据库
     * @param cacheInterval
     * @returns
     */
    init(cacheInterval) {
        {
            coreLog(`[DBCacheComponentMgr] init, cacheInterval: ${cacheInterval}`);
        }
        this.startTimer(cacheInterval);
        return this;
    }
    async startTimer(cacheInterval) {
        while (true) {
            if (this.isDisposed) {
                break;
            }
            await TimerMgr.getInst().waitAsync(cacheInterval);
            await this.saveNow();
        }
    }
    async saveNow() {
        let start = Date.now();
        let list = [];
        for (let cache of this._cacheList) {
            list.push(cache.saveToDB());
        }
        await Promise.all(list);
        {
            let cost = Date.now() - start;
            if (cost > 3000) {
                coreWarn(`[DBCacheComponentMgr]储存数据到db消耗时间过长,请考虑优化,cost=${cost}ms`);
            }
        }
    }
    getCacheCom(type) {
        return this._type2ComMap.get(type);
    }
}

var SceneTypeCore;
(function (SceneTypeCore) {
    SceneTypeCore["None"] = "None";
    SceneTypeCore["Process"] = "Process";
    SceneTypeCore["Realm"] = "Realm";
    SceneTypeCore["Gate"] = "Gate";
    SceneTypeCore["Location"] = "Location";
    SceneTypeCore["DBCache"] = "DBCache";
    SceneTypeCore["Map"] = "Map";
})(SceneTypeCore || (SceneTypeCore = {}));

var __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * 代表着玩家的一个实体
 * 也就是一个Unit代表一个客户端
 * 比如玩家登录 进入gate,那么unit就添加在gate上，进入map那么unit就会传送到map上
 */
let Unit = class Unit extends Entity {
};
Unit = __decorate$t([
    DBWithKey('id', true, 1000)
], Unit);

class UnitComponent extends Entity {
    get(id) {
        let unit = this.getChild(Unit, id);
        return unit;
    }
    remove(id) {
        let unit = this.getChild(Unit, id);
        unit?.dispose();
    }
}

/**
 * 管理Gate上的MapScene
 */
class GateMapComponent extends Entity {
    awake() {
        this.mapScene = EntitySceneFactory.createScene({
            sceneType: SceneTypeCore.Map,
            id: IdGenerator.getInst().generateId(),
            name: 'GateMap',
            parent: this,
        });
        this.mapScene.addComponent(UnitComponent);
    }
    addUnit(unit) {
        this.mapScene.getComponent(UnitComponent).addChild(unit);
    }
}

// 此文件为自动生成，请勿手工修改！
var InnerMessageCoreOpcode;
(function (InnerMessageCoreOpcode) {
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["_ActorResponse"] = 1000] = "_ActorResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["DBCacheResponse"] = 1001] = "DBCacheResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["DBQueryResponse"] = 1003] = "DBQueryResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["DBDeleteResponse"] = 1005] = "DBDeleteResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectAddResponse"] = 1008] = "ObjectAddResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectGetResponse"] = 1010] = "ObjectGetResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectLockResponse"] = 1011] = "ObjectLockResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectRemoveResponse"] = 1014] = "ObjectRemoveResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectUnLockResponse"] = 1016] = "ObjectUnLockResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["G2R_GetLoginKey"] = 1017] = "G2R_GetLoginKey";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["M2G_ConnectUnit"] = 1020] = "M2G_ConnectUnit";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["M2G_DisconnectUnit"] = 1022] = "M2G_DisconnectUnit";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["M2M_UnitTransferResponse"] = 1023] = "M2M_UnitTransferResponse";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["DBCacheRequest"] = 1002] = "DBCacheRequest";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["DBQueryRequest"] = 1004] = "DBQueryRequest";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["DBDeleteRequest"] = 1006] = "DBDeleteRequest";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectAddRequest"] = 1007] = "ObjectAddRequest";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectGetRequest"] = 1009] = "ObjectGetRequest";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectLockRequest"] = 1012] = "ObjectLockRequest";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectRemoveRequest"] = 1013] = "ObjectRemoveRequest";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["ObjectUnLockRequest"] = 1015] = "ObjectUnLockRequest";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["R2G_GetLoginKey"] = 1018] = "R2G_GetLoginKey";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["G2M_ConnectUnit"] = 1019] = "G2M_ConnectUnit";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["G2M_DisconnectUnit"] = 1021] = "G2M_DisconnectUnit";
    InnerMessageCoreOpcode[InnerMessageCoreOpcode["M2M_UnitTransferRequest"] = 1024] = "M2M_UnitTransferRequest";
})(InnerMessageCoreOpcode || (InnerMessageCoreOpcode = {}));

// 此文件为自动生成，请勿手工修改！
var __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * ActorLocationMessage需要这个来回应
 */
let _ActorResponse = class _ActorResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
_ActorResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode._ActorResponse, 'ActorResponse')
], _ActorResponse);
/**
 * 缓存数据库 加回应是为了确保能等待缓存结束
 */
let DBCacheResponse = class DBCacheResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
DBCacheResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.DBCacheResponse, 'ActorResponse')
], DBCacheResponse);
/**
 * 数据库查询
 */
let DBQueryResponse = class DBQueryResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
DBQueryResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.DBQueryResponse, 'ActorResponse')
], DBQueryResponse);
/**
 * 数据库删除
 */
let DBDeleteResponse = class DBDeleteResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
DBDeleteResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.DBDeleteResponse, 'ActorResponse')
], DBDeleteResponse);
let ObjectAddResponse = class ObjectAddResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectAddResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.ObjectAddResponse, 'ActorResponse')
], ObjectAddResponse);
let ObjectGetResponse = class ObjectGetResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectGetResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.ObjectGetResponse, 'ActorResponse')
], ObjectGetResponse);
let ObjectLockResponse = class ObjectLockResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectLockResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.ObjectLockResponse, 'ActorResponse')
], ObjectLockResponse);
let ObjectRemoveResponse = class ObjectRemoveResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectRemoveResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.ObjectRemoveResponse, 'ActorResponse')
], ObjectRemoveResponse);
let ObjectUnLockResponse = class ObjectUnLockResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectUnLockResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.ObjectUnLockResponse, 'ActorResponse')
], ObjectUnLockResponse);
let G2R_GetLoginKey = class G2R_GetLoginKey {
    constructor(args) {
        Object.assign(this, args);
    }
};
G2R_GetLoginKey = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.G2R_GetLoginKey, 'ActorResponse')
], G2R_GetLoginKey);
let M2G_ConnectUnit = class M2G_ConnectUnit {
    constructor(args) {
        Object.assign(this, args);
    }
};
M2G_ConnectUnit = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.M2G_ConnectUnit, 'ActorLocationResponse')
], M2G_ConnectUnit);
let M2G_DisconnectUnit = class M2G_DisconnectUnit {
    constructor(args) {
        Object.assign(this, args);
    }
};
M2G_DisconnectUnit = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.M2G_DisconnectUnit, 'ActorLocationResponse')
], M2G_DisconnectUnit);
let M2M_UnitTransferResponse = class M2M_UnitTransferResponse {
    constructor(args) {
        Object.assign(this, args);
    }
};
M2M_UnitTransferResponse = __decorate$s([
    MessageDecorator(InnerMessageCoreOpcode.M2M_UnitTransferResponse, 'ActorResponse')
], M2M_UnitTransferResponse);
/**
 * 缓存数据库
 */
let DBCacheRequest = class DBCacheRequest {
    constructor(args) {
        Object.assign(this, args);
    }
};
DBCacheRequest = __decorate$s([
    ResponseTypeDecorator(DBCacheResponse),
    MessageDecorator(InnerMessageCoreOpcode.DBCacheRequest, 'ActorRequest')
], DBCacheRequest);
/**
 * 数据库查询
 */
let DBQueryRequest = class DBQueryRequest {
    constructor(args) {
        Object.assign(this, args);
    }
};
DBQueryRequest = __decorate$s([
    ResponseTypeDecorator(DBQueryResponse),
    MessageDecorator(InnerMessageCoreOpcode.DBQueryRequest, 'ActorRequest')
], DBQueryRequest);
/**
 * 数据库删除
 */
let DBDeleteRequest = class DBDeleteRequest {
    constructor(args) {
        Object.assign(this, args);
    }
};
DBDeleteRequest = __decorate$s([
    ResponseTypeDecorator(DBDeleteResponse),
    MessageDecorator(InnerMessageCoreOpcode.DBDeleteRequest, 'ActorRequest')
], DBDeleteRequest);
let ObjectAddRequest = class ObjectAddRequest {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectAddRequest = __decorate$s([
    ResponseTypeDecorator(ObjectAddResponse),
    MessageDecorator(InnerMessageCoreOpcode.ObjectAddRequest, 'ActorRequest')
], ObjectAddRequest);
let ObjectGetRequest = class ObjectGetRequest {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectGetRequest = __decorate$s([
    ResponseTypeDecorator(ObjectGetResponse),
    MessageDecorator(InnerMessageCoreOpcode.ObjectGetRequest, 'ActorRequest')
], ObjectGetRequest);
let ObjectLockRequest = class ObjectLockRequest {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectLockRequest = __decorate$s([
    ResponseTypeDecorator(ObjectLockResponse),
    MessageDecorator(InnerMessageCoreOpcode.ObjectLockRequest, 'ActorRequest')
], ObjectLockRequest);
let ObjectRemoveRequest = class ObjectRemoveRequest {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectRemoveRequest = __decorate$s([
    ResponseTypeDecorator(ObjectRemoveResponse),
    MessageDecorator(InnerMessageCoreOpcode.ObjectRemoveRequest, 'ActorRequest')
], ObjectRemoveRequest);
let ObjectUnLockRequest = class ObjectUnLockRequest {
    constructor(args) {
        Object.assign(this, args);
    }
};
ObjectUnLockRequest = __decorate$s([
    ResponseTypeDecorator(ObjectUnLockResponse),
    MessageDecorator(InnerMessageCoreOpcode.ObjectUnLockRequest, 'ActorRequest')
], ObjectUnLockRequest);
let R2G_GetLoginKey = class R2G_GetLoginKey {
    constructor(args) {
        Object.assign(this, args);
    }
};
R2G_GetLoginKey = __decorate$s([
    ResponseTypeDecorator(G2R_GetLoginKey),
    MessageDecorator(InnerMessageCoreOpcode.R2G_GetLoginKey, 'ActorRequest')
], R2G_GetLoginKey);
/**
 * 连接unit
 */
let G2M_ConnectUnit = class G2M_ConnectUnit {
    constructor(args) {
        Object.assign(this, args);
    }
};
G2M_ConnectUnit = __decorate$s([
    ResponseTypeDecorator(M2G_ConnectUnit),
    MessageDecorator(InnerMessageCoreOpcode.G2M_ConnectUnit, 'ActorLocationRequest')
], G2M_ConnectUnit);
/**
 * 与unit断开连接
 */
let G2M_DisconnectUnit = class G2M_DisconnectUnit {
    constructor(args) {
        Object.assign(this, args);
    }
};
G2M_DisconnectUnit = __decorate$s([
    ResponseTypeDecorator(M2G_DisconnectUnit),
    MessageDecorator(InnerMessageCoreOpcode.G2M_DisconnectUnit, 'ActorLocationRequest')
], G2M_DisconnectUnit);
/**
 * 传送unit
 */
let M2M_UnitTransferRequest = class M2M_UnitTransferRequest {
    constructor(args) {
        this.entitys = [];
        Object.assign(this, args);
    }
};
M2M_UnitTransferRequest = __decorate$s([
    ResponseTypeDecorator(M2M_UnitTransferResponse),
    MessageDecorator(InnerMessageCoreOpcode.M2M_UnitTransferRequest, 'ActorRequest')
], M2M_UnitTransferRequest);

var NetworkProtocol;
(function (NetworkProtocol) {
    NetworkProtocol[NetworkProtocol["TCP"] = 0] = "TCP";
    NetworkProtocol[NetworkProtocol["Websocket"] = 1] = "Websocket";
})(NetworkProtocol || (NetworkProtocol = {}));

/**
 * 收到内网来的消息后 根据messageType分发到不同的消息处理器
 */
class InnerMessageDispatcher extends Singleton {
    constructor() {
        super(...arguments);
        this._handlers = new Map();
    }
    awake() {
        let list = DecoratorCollector.inst.get(DecoratorType.InnerMsgHandler);
        for (const args of list) {
            let handlerType = args[0];
            let msgType = args[1];
            let handler = new handlerType();
            this._handlers.set(msgType, handler);
        }
    }
    handle(actorId, msg) {
        let messageType = MessageTypeMgr.getInst().getMessageType(msg.constructor);
        let handler = this._handlers.get(messageType);
        if (!handler) {
            coreError('InnerMessageMsgDispatcher handle not found handler', messageType);
            return;
        }
        handler.run(actorId, msg);
    }
}

/**
 * 服务端不同序号的进程通信
 */
class NetInnerComponent extends Entity {
    constructor() {
        super(...arguments);
        this.InnerProtocol = NetworkProtocol.Websocket;
    }
    awake() {
        this.delayInit();
        NetInnerComponent.inst = this;
    }
    destroy() {
        NetInnerComponent.inst = null;
        NetServices.getInst().RemoveService(this.ServiceId);
    }
    async delayInit() {
        await TimerMgr.getInst().waitAsync(5 * 1000);
        let curProcessInfo = ProcessMgr.getInst().getCurProcessInfo();
        let address = curProcessInfo.innerAddress;
        let netServices = NetServices.getInst();
        coreLog('[进程{0}]内网开启监听: {1}', curProcessInfo.id, address.toString());
        switch (this.InnerProtocol) {
            case NetworkProtocol.TCP:
                {
                    // 等待实现
                    break;
                }
            case NetworkProtocol.Websocket:
                {
                    let service = new WService();
                    service.initAcceptor(address, ServiceType.Inner);
                    this.ServiceId = netServices.AddService(service);
                    break;
                }
        }
        netServices.RegisterAcceptCallback(this.ServiceId, this.onAccept.bind(this));
        netServices.RegisterReadCallback(this.ServiceId, this.onRead.bind(this));
        netServices.RegisterErrorCallback(this.ServiceId, this.onError.bind(this));
    }
    onRead(channelId, actorId, message) {
        let session = this.getChild(Session, channelId);
        if (session == null) {
            return;
        }
        session.LastRecvTime = TimeHelper.clientFrameTime();
        this.handleMessage(actorId, message);
    }
    handleMessage(actorId, message) {
        // let rootSecene = Root.getInst().scene
        InnerMessageDispatcher.getInst().handle(actorId, message);
        // EventSender.getInst().publish(rootSecene, NetInnerComponentOnRead.create({ ActorId: actorId, Message: message }));
    }
    onError(channelId, error) {
        let session = this.getChild(Session, channelId);
        if (session == null) {
            return;
        }
        session.Error = error;
        session.dispose();
    }
    onAccept(channelId, ipEndPoint) {
        let session = this.addChildWithId(Session, channelId);
        session.init(this.ServiceId);
        session.RemoteAddress = ipEndPoint;
    }
    createInner(channelId, ipEndPoint) {
        let session = this.addChildWithId(Session, channelId);
        session.init(this.ServiceId);
        session.RemoteAddress = ipEndPoint;
        NetServices.getInst().CreateChannel(this.ServiceId, channelId, ipEndPoint);
        return session;
    }
    // 内网actor session，channelId是进程号
    get(channelId) {
        let session = this.getChild(Session, channelId);
        if (session != null) {
            return session;
        }
        let currentProcessId = Options.getInst().process;
        let currentProcessInfo = ProcessMgr.getInst().getProcessInfo(currentProcessId);
        let targetProcessInfo = ProcessMgr.getInst().getProcessInfo(channelId);
        let ipEndPoint;
        if (targetProcessInfo == null) {
            coreError('目标进程不存在, channelId={0}', channelId);
            return;
        }
        if (currentProcessInfo == null) {
            coreError('当前进程不存在, processId={0}', currentProcessId);
            return;
        }
        {
            // 同一台机器 走内网地址
            if (targetProcessInfo.machineId == currentProcessInfo.machineId) {
                coreLog('同一台机器，走内网地址, 当前进程={0}, 目标进程={1}', currentProcessInfo.id, targetProcessInfo.id);
                ipEndPoint = targetProcessInfo.innerAddress;
            }
            else {
                ipEndPoint = targetProcessInfo.outerAddress;
            }
        }
        session = this.createInner(channelId, ipEndPoint);
        return session;
    }
}

/**
 * 转化actorId的进程号，使其发送过去可以返回到本进程
 */
class ProcessActorId {
    init(actorId) {
        let objectPool = ObjectPool.getInst();
        let instanceIdStruct = objectPool.fetch(InstanceIdStruct);
        instanceIdStruct.initArgs1(actorId);
        // 获取actorId的进程号
        this.Process = instanceIdStruct.Process;
        // 设置自己的进程号
        instanceIdStruct.Process = Options.getInst().process;
        instanceIdStruct.updateResult();
        // 返回新的id
        this.ActorId = instanceIdStruct.ToLong();
        objectPool.recycle(instanceIdStruct);
    }
}

/**
 * 获取一个消息的回应类型
 */
class ResponseTypeMgr extends Singleton {
    constructor() {
        super(...arguments);
        this._requestResponse = new Map();
    }
    awake() {
        let list2 = DecoratorCollector.inst.get(DecoratorTypeCore.Message);
        for (const args of list2) {
            let type = args[0];
            let msgType = args[1];
            if (msgType == MessageTypeCore.ActorLocationMessage) {
                this._requestResponse.set(type, _ActorResponse);
            }
        }
        let list = DecoratorCollector.inst.get(DecoratorTypeCore.MessageResponse);
        for (const args of list) {
            let request = args[0];
            let response = args[1];
            this._requestResponse.set(request, response);
        }
    }
    getResponseType(request) {
        let response = this._requestResponse.get(request);
        {
            if (!response) {
                throw new Error(`not found response type, request type: ${request.name}`);
            }
        }
        return response;
    }
}

class ActorHelper {
    /**
     * 创建消息的回应实例
     * @param iActorRequest
     * @param error
     * @returns
     */
    static createResponse(iActorRequest, error) {
        let responseType = ResponseTypeMgr.getInst().getResponseType(iActorRequest.constructor);
        let response = new responseType();
        response.error = error;
        response.rpcId = iActorRequest.rpcId;
        return response;
    }
}

// 知道对方的instanceId，使用这个类发actor消息
class ActorMessageSender {
    constructor(actorId, iActorRequest, tcs) {
        this.ActorId = actorId;
        this.Request = iActorRequest;
        this.CreateTime = TimeHelper.serverNow();
        this.Tcs = tcs;
    }
    run(response) {
        if (response.error == ErrorCore.ERR_ActorTimeout) {
            coreLog(`${this.Request.constructor.name}超时了, 请检查`);
        }
        // if (this.NeedException && ErrorCore.IsRpcNeedThrowException(response.error)) {
        //     coreError(`Rpc error: actorId: ${this.ActorId} request: `, this.Request, "response:", response);
        // }
        this.Tcs.setResult(response);
        this.Tcs = null;
    }
}

/**
 * 发送actor消息
 */
class ActorMessageSenderMgr extends Singleton {
    constructor() {
        super(...arguments);
        this.TIMEOUT_TIME = 10 * 1000;
        this.RpcId = 1;
        this.requestCallback = new Map;
        this.TimeoutActorMessageSenders = new Array;
    }
    awake() {
        this.TimeoutCheckTimer = TimerMgr.getInst().newRepeatedTimer(1000, this.check.bind(this));
    }
    destroy() {
        TimerMgr.getInst().remove(this.TimeoutCheckTimer);
        this.TimeoutCheckTimer = 0;
        this.TimeoutActorMessageSenders = [];
    }
    check() {
        let timeNow = TimeHelper.serverNow();
        for (let [key, value] of this.requestCallback) {
            // 因为是顺序发送的，所以，检测到第一个不超时的就退出
            if (timeNow < value.CreateTime + this.TIMEOUT_TIME) {
                break;
            }
            this.TimeoutActorMessageSenders.push(key);
        }
        for (let i = 0; i < this.TimeoutActorMessageSenders.length; i++) {
            const rpcId = this.TimeoutActorMessageSenders[i];
            let actorMessageSender = this.requestCallback.get(rpcId);
            this.requestCallback.delete(rpcId);
            try {
                let response = ActorHelper.createResponse(actorMessageSender.Request, ErrorCore.ERR_ActorTimeout);
                actorMessageSender.run(response);
            }
            catch (e) {
                coreError(e);
            }
        }
        this.TimeoutActorMessageSenders = [];
    }
    /**
     * 建议使用ActorMsgHelper去调用
     * @param actorId
     * @param message
     * @returns
     * @发送顺序 可以保证
     */
    send(actorId, message) {
        if (actorId == 0) {
            coreError(`actor id is 0: ${message}`);
            return;
        }
        let objectPool = ObjectPool.getInst();
        let processActorId = objectPool.fetch(ProcessActorId);
        processActorId.init(actorId);
        {
            // 这里做了优化，如果发向同一个进程，则直接处理，不需要通过网络层
            if (processActorId.Process == Options.getInst().process) {
                NetInnerComponent.inst.handleMessage(actorId, message);
                return;
            }
        }
        try {
            let session = NetInnerComponent.inst.get(processActorId.Process);
            session.SendWithId(processActorId.ActorId, message);
        }
        catch (e) {
            coreError('ActorMessageSenderMgr.send error, actorid={0}, msg={1}, {2}', actorId, message.constructor.name, e.stack);
        }
        objectPool.recycle(processActorId);
    }
    getRpcId() {
        let rpcId = ++this.RpcId;
        if (this.RpcId > 1000000) {
            this.RpcId = 1;
        }
        return rpcId;
    }
    /**
     * 这个方法的调用要注意catch error
     * 此方法内部是没有进行错误捕获的
     * @param actorId
     * @param rpcId
     * @param iActorRequest
     * @returns
     * @发送顺序 无法保证
     */
    async callWithRpcId(actorId, rpcId, iActorRequest) {
        if (actorId == 0) {
            let response = ActorHelper.createResponse(iActorRequest, ErrorCore.ERR_ActorIdIsZero);
            return response;
        }
        let tcs = Task.create();
        // todo ActorMessageSender改用对象池
        this.requestCallback.set(rpcId, new ActorMessageSender(actorId, iActorRequest, tcs));
        this.send(actorId, iActorRequest);
        let beginTime = TimeHelper.serverFrameTime();
        let response = await tcs;
        let endTime = TimeHelper.serverFrameTime();
        let costTime = endTime - beginTime;
        // todo 做消息筛选 有些内部消息需要等待回应,同时处理的时候,有协程锁,会导致消息处理时间变长
        // 比如ObjectRemoveRequest, 它大于200也很正常
        if (costTime > 200) {
            coreLog(`actor rpc time > 200: ${costTime} ${iActorRequest.constructor.name}`);
        }
        return response;
    }
    /**
     * 建议使用ActorMsgHelper去调用
     * 这里内部进行错误捕获，不会抛出异常
     * @param actorId
     * @param request
     * @param needException
     * @returns
     * @发送顺序 无法保证
     */
    async call(actorId, request) {
        try {
            request.rpcId = this.getRpcId();
            if (actorId == 0) {
                let response = ActorHelper.createResponse(request, ErrorCore.ERR_ActorIdIsZero);
                return response;
            }
            let result = await this.callWithRpcId(actorId, request.rpcId, request);
            return result;
        }
        catch (e) {
            coreError('ActorMessageSenderMgr.call error, actorid={0}, msg={1}, {2}', actorId, request.constructor.name, e.stack);
            let response = ActorHelper.createResponse(request, ErrorCore.ERR_ActorTimeout);
            return response;
        }
    }
    handleActorResponse(response) {
        let actorMessageSender = this.requestCallback.get(response.rpcId);
        if (!actorMessageSender) {
            return;
        }
        this.requestCallback.delete(response.rpcId);
        actorMessageSender.run(response);
    }
}

class ActorMsgHelper {
    /**
     * 发送actor消息 可以有返回消息
     * @param actorId 其实就是instanceId
     * @param request
     * @param responseType
     * @returns
     */
    static async call(actorId, request, responseType) {
        let response = await ActorMessageSenderMgr.getInst().call(actorId, request);
        return response;
    }
    /**
     * 发送actor消息 不带返回消息
     * @param actorId
     * @param request
     */
    static send(actorId, request) {
        ActorMessageSenderMgr.getInst().send(actorId, request);
    }
}

/**
 * 对象序列化
 * 需要用装饰器先注册一下
 * 比如 DB Transfer DBWithKey
 */
class ObjectSerializeMgr extends Singleton {
    constructor() {
        super(...arguments);
        this.typeMap = new Map;
        this.typeCodeMap = new Map;
    }
    awake() {
        let typeList = [];
        let list1 = DecoratorCollector.inst.get(DecoratorTypeCore.Transfer);
        for (const args of list1) {
            let type = args[0];
            typeList.push(type);
        }
        let list2 = DecoratorCollector.inst.get(DecoratorTypeCore.DB);
        for (const args of list2) {
            let type = args[0];
            typeList.push(type);
        }
        for (let i = 0; i < typeList.length; i++) {
            let type = typeList[i];
            let cfg = {
                type: type,
                typeCode: 40500 + i + 1,
            };
            this.typeMap.set(type, cfg);
            this.typeCodeMap.set(cfg.typeCode, cfg);
            coreLog('ObjectSerializeMgr 注册类型 = {0}, typeCode = {1}', cfg.type.name, cfg.typeCode);
            addExtension({
                Class: cfg.type,
                tag: cfg.typeCode,
                encode(instance, encode) {
                    if (instance.onSerialize) {
                        instance.onSerialize();
                    }
                    return encode(Object.assign({}, instance));
                },
                decode(data) {
                    Object.setPrototypeOf(data, type.prototype);
                    if (data.onDeserialize) {
                        data.onDeserialize();
                    }
                    return data;
                }
            });
        }
        this._encoder = new Encoder({ structuredClone: true });
        this._sameMachineEncoder = new Encoder({
            structuredClone: true,
            structures: [],
            getStructures() {
                return decode(readFileSync('cbor-x-structures.cbor')) || [];
            },
            saveStructures(structures) {
                writeFileSync('cbor-x-structures.cbor', encode(structures));
            },
        });
        coreLog('ObjectSerializeMgr nodejs环境加速是否开启: {0}', isNativeAccelerationEnabled);
        if (!isNativeAccelerationEnabled) {
            coreWarn('ObjectSerializeMgr nodejs环境加速没开启, 请检查cbor-x的依赖是否正常');
        }
    }
    serialize(obj) {
        let serialized = this._encoder.encode(obj);
        let bytes = new Uint8Array(serialized);
        // coreLog(`不同机器序列化`);
        return bytes;
    }
    serializeSameMachine(obj) {
        let serialized;
        {
            serialized = this._sameMachineEncoder.encode(obj);
        }
        let bytes = new Uint8Array(serialized);
        return bytes;
    }
    deserialize(bytes) {
        let obj = this._encoder.decode(bytes);
        // coreLog(`不同机器反序列化`)
        return obj;
    }
    deserializeSameMachine(bytes) {
        let obj;
        {
            obj = this._sameMachineEncoder.decode(bytes);
        }
        return obj;
    }
    getTypeCode(type) {
        let cfg = this.typeMap.get(type);
        {
            if (cfg == null) {
                throw new Error(`不存在typecode的类型, type=${type}`);
            }
        }
        return cfg.typeCode;
    }
    getType(typeCode) {
        let cfg = this.typeCodeMap.get(typeCode);
        {
            if (cfg == null) {
                throw new Error(`不存在typecode的类型, typeCode=${typeCode}`);
            }
        }
        return cfg.type;
    }
}

class DBHelper {
    /**
     * 就一个缓存服 需要的话可以改成多个
     * @param key
     * @returns
     */
    static getDB() {
        let dbSceneInfos = SceneMgr.getInst().getSceneByType(SceneTypeCore.DBCache);
        return dbSceneInfos[0].instanceId;
    }
    /**
     * 返回两个参数 一个是错误码 一个是查询结果
     * @param type
     * @param key
     * @returns
     */
    static async query(type, key) {
        let instanceId = this.getDB();
        let serializeMgr = ObjectSerializeMgr.getInst();
        let typeCode = serializeMgr.getTypeCode(type);
        let msg = new DBQueryRequest();
        if (typeof key == "number") {
            msg.numberKey = key;
        }
        else {
            msg.stringKey = key;
        }
        msg.typeCode = typeCode;
        let response = await ActorMsgHelper.call(instanceId, msg, DBQueryResponse);
        if (response.error != ErrorCore.ERR_Success) {
            coreError('DBHelper.query查询失败,error= {0}', response.error);
            return [response.error, null];
        }
        if (response.data == null) {
            return [response.error, null];
        }
        let isSameMachine = ProcessMgr.getInst().actorIdIsInMachine(instanceId);
        // coreLog('向db缓存查询类型: {0}', type.name);
        let obj = isSameMachine ? serializeMgr.deserializeSameMachine(response.data) : serializeMgr.deserialize(response.data);
        // MsgPrinter.getInst().print(obj, '向db缓存查询类型返回结果');
        return [response.error, obj];
    }
    static async save(obj) {
        if (obj == null) {
            coreLog(`dbhelper保存对象为null`);
            return false;
        }
        if (obj.constructor == null) {
            coreLog(`dbhelper保存对象的构造函数为null`);
            return false;
        }
        let serializeMgr = ObjectSerializeMgr.getInst();
        let instanceId = this.getDB();
        let isSameMachine = ProcessMgr.getInst().actorIdIsInMachine(instanceId);
        let data = isSameMachine ? serializeMgr.serializeSameMachine(obj) : serializeMgr.serialize(obj);
        // coreLog(`请求db缓存类型: ${obj.constructor.name}`)
        let response = await ActorMsgHelper.call(instanceId, new DBCacheRequest({ data: data }), DBCacheResponse);
        if (response.error != ErrorCore.ERR_Success) {
            coreError('DBHelper.save保存失败,error= {0}, type={1}', response.error, obj.constructor.name);
            return false;
        }
        return true;
    }
    static async delete(type, key) {
        let instanceId = this.getDB();
        let serializeMgr = ObjectSerializeMgr.getInst();
        let typeCode = serializeMgr.getTypeCode(type);
        let msg = new DBDeleteRequest();
        msg.typeCode = typeCode;
        if (typeof key == "number") {
            msg.numberKey = key;
        }
        else {
            msg.stringKey = key;
        }
        let response = await ActorMsgHelper.call(instanceId, msg, DBDeleteResponse);
        if (response.error != ErrorCore.ERR_Success) {
            coreError(`DBHelper.delete删除失败,error=${response.error}`);
        }
    }
}

var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * 玩家数据
 * 每个账号都有一个GatePlayer
 * 用来保存账号的一些信息 比如角色列表等
 */
let GatePlayer = class GatePlayer extends Entity {
    constructor() {
        super(...arguments);
        this.ref = 0;
    }
    get account() {
        return this._account;
    }
    init(account) {
        this._account = account;
        return this;
    }
    onDeserialize() {
        this.ref = 0;
    }
    /**
     * 注意 这里创建是有可能失败的
     * @param args
     * @returns 创建是否成功
     */
    async createUnit(args) {
        let unit = this.addChild(Unit);
        await EventSystem.getInst().publishAsync(this.domainScene(), AfterCreateUnit.create({ unit: unit, args: args }));
        let ret = await DBHelper.save(unit);
        if (!ret) {
            return false;
        }
        unit.dispose();
        return true;
    }
};
__decorate$r([
    IgnoreSerialize
], GatePlayer.prototype, "ref", void 0);
GatePlayer = __decorate$r([
    DBWithKey('_account', false, 1000)
], GatePlayer);

/**
 * 挂在GatePlayer上保存sessionId
 * 这样如果有新的session连接gate，就可以销毁上一个session了
 * 这样就不会出现一个账号多个session的情况
 */
class PlayerSessionComponent extends Entity {
}

/**
 * 连接unit以后保存unit的id
 */
class GatePlayerUnitComponent extends Entity {
    constructor() {
        super(...arguments);
        this.unitId = 0;
    }
}

/**
 * GatePlayer的父节点
 */
class GatePlayerComponent extends Entity {
    constructor() {
        super(...arguments);
        this._accountPlayers = new Map();
    }
    async getPlayer(account) {
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.GetGatePlayer, account);
        try {
            let player = this._accountPlayers.get(account);
            // 不在线 得从数据库拿
            if (!player) {
                let [err, result] = await DBHelper.query(GatePlayer, account);
                if (err != ErrorCore.ERR_Success) {
                    return null;
                }
                player = result;
            }
            else { // 在线 且拿到了 直接返回
                return player;
            }
            // 数据库也没有 则创建一个
            if (!player) {
                player = this.addChild(GatePlayer).init(account);
                await EventSystem.getInst().publishAsync(this.domainScene(), AfterCreateGatePlayer.create({ player: player }));
            }
            else { // 有的话 给他添加父节点
                this.addChild(player);
            }
            player.addComponent(PlayerSessionComponent);
            player.addComponent(GatePlayerUnitComponent);
            this._accountPlayers.set(account, player);
            return player;
        }
        finally {
            lock.dispose();
        }
    }
    removePlayer(account) {
        this._accountPlayers.delete(account);
    }
}

/**
 * 生成一个key， 用于客户端连接gate，客户端如果没有这个key，是无法连接gate的
 */
class GateSessionKeyComponent extends Entity {
    constructor() {
        super(...arguments);
        this._sessionKey = new Map();
    }
    newKey(account) {
        let key;
        for (let i = 0; i < 1000; i++) {
            key = RandomGenerator.RandomInt(1, 9999999);
            if (!this._sessionKey.has(key)) {
                break;
            }
        }
        this.add(key, account);
        return key;
    }
    add(key, account) {
        this._sessionKey.set(key, account);
        this.timeoutRemoveKey(key);
    }
    getAccount(key) {
        let account = this._sessionKey.get(key);
        return account;
    }
    remove(key) {
        this._sessionKey.delete(key);
    }
    /**
     * 20秒还不来验证，就删除这个key
     * @param key
     */
    async timeoutRemoveKey(key) {
        await TimerMgr.getInst().waitAsync(20 * 1000);
        this._sessionKey.delete(key);
    }
}

/**
 * 锁定instanceId的信息
 * todo 改成class用对象池可能会更好
 */
class LockInfo extends Entity {
    init(lockInstanceId, coroutineLock) {
        this.CoroutineLock = coroutineLock;
        this.LockInstanceId = lockInstanceId;
        return this;
    }
    destroy() {
        this.CoroutineLock.dispose();
        this.LockInstanceId = 0;
    }
}

/**
 * 位置组件
 * 比如unit每次传送都要上报instanceId, 这个组件就是用来查询unitId对应的instanceId的
 * instanceId包含了unit所在进程 也就是所在的位置
 */
class LocationComponent extends Entity {
    constructor() {
        super(...arguments);
        this.locations = new Map();
        this.lockInfos = new Map();
    }
    async add(key, instanceId) {
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.Location, key.toString());
        try {
            this.locations.set(key, instanceId);
            coreLog(`location add key: ${key} instanceId: ${instanceId}`);
        }
        finally {
            lock.dispose();
        }
    }
    async remove(key) {
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.Location, key.toString());
        try {
            this.locations.delete(key);
            coreLog(`location remove key: ${key}`);
        }
        finally {
            lock.dispose();
        }
    }
    async lock(key, instanceId, time = 0) {
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.Location, key.toString());
        let lockInfo = this.addChild(LockInfo).init(instanceId, lock);
        this.lockInfos.set(key, lockInfo);
        coreLog(`location lock key: ${key} instanceId: ${instanceId}`);
        // todo 改成类方法
        if (time > 0) {
            let timeWaitAsync = async () => {
                let lockInfoInstanceId = lockInfo.instanceId;
                await TimerMgr.getInst().waitAsync(time);
                if (lockInfo.instanceId != lockInfoInstanceId) {
                    return;
                }
                this.unLock(key, instanceId, instanceId);
            };
            timeWaitAsync();
        }
    }
    unLock(key, oldInstanceId, newInstanceId) {
        let lockInfo = this.lockInfos.get(key);
        if (!lockInfo) {
            coreError(`location unlock not found key: ${key} {oldInstanceId}`);
            return;
        }
        if (oldInstanceId != lockInfo.LockInstanceId) {
            coreError(`location unlock oldInstanceId is different: ${key} {oldInstanceId}`);
            return;
        }
        coreLog(`location unlock key: ${key} instanceId: ${oldInstanceId} newInstanceId: ${newInstanceId}`);
        this.locations.set(key, newInstanceId);
        this.lockInfos.delete(key);
        // 解锁
        lockInfo.dispose();
    }
    async get(key) {
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.Location, key.toString());
        try {
            let instanceId = this.locations.get(key);
            return instanceId;
        }
        finally {
            lock.dispose();
        }
    }
}

/**
 * 为什么不用事件呢 因为事件没办法保证顺序
 * 这里需要在创建场景后比框架外先执行
 */
class AfterCreateSceneHandler {
    static run(scene, sceneInfo) {
        switch (sceneInfo.sceneType) {
            case SceneTypeCore.DBCache: {
                // 允许不配置数据库 比如开发阶段
                if (sceneInfo.dbAddress != null && sceneInfo.dbAddress.length > 0) {
                    scene.addComponent(DBComponent).init(sceneInfo.dbAddress, sceneInfo.dbName);
                }
                let dbCacheInterval = sceneInfo.dbCacheInterval || 5 * 60 * 1000;
                scene.addComponent(DBCacheComponentMgr).init(dbCacheInterval);
                break;
            }
            case SceneTypeCore.Gate: {
                scene.addComponent(GateSessionKeyComponent);
                scene.addComponent(GatePlayerComponent);
                scene.addComponent(GateMapComponent);
                break;
            }
            case SceneTypeCore.Map: {
                scene.addComponent(UnitComponent);
                break;
            }
            case SceneTypeCore.Location: {
                scene.addComponent(LocationComponent);
                break;
            }
        }
    }
}

/**
 * scene工厂
 */
class SceneFactory {
    static createByInfo(parent, info) {
        let scene = EntitySceneFactory.createScene({
            id: info.id,
            instanceId: info.instanceId,
            sceneType: info.sceneType,
            name: info.name,
            parent: parent,
        });
        scene.addComponent(MailBoxComponent).init(MailboxType.UnOrderMessageDispatcher);
        /**
         * 如果有外网端口的话 就开启外网服务
         */
        if (info.outerPort) {
            let listenAddress = new IPEndPoint(info.innerIp, info.outerPort);
            scene.addComponent(NetServerComponent).init(listenAddress);
        }
        // 方便在框架内部先进行一些处理
        AfterCreateSceneHandler.run(scene, info);
        let rootScene = Root.getInst().scene;
        EventSystem.getInst().publish(rootScene, SceneCreateEvent.create({
            scene: scene,
            sceneInfo: info,
        }));
        return scene;
    }
    /**
     * child scene不会注册到scenemgr 需要自己管理
     * @param parent
     * @param args
     */
    static createChildScene(parent, args) {
        let sceneMgr = SceneMgr.getInst();
        let parentSceneInfo = sceneMgr.getSceneById(parent.id);
        let instanceId = args.instanceId;
        if (!instanceId) {
            instanceId = InstanceIdHelper.getSceneInstanceId(parentSceneInfo.processId, args.id);
        }
        return this.createByInfo(parent, {
            id: args.id,
            name: args.name,
            innerIp: parentSceneInfo.innerIp,
            outerIp: parentSceneInfo.outerIp,
            machineId: parentSceneInfo.machineId,
            processId: parentSceneInfo.processId,
            sceneType: args.sceneType,
            instanceId: instanceId,
        });
    }
}

/**
 * 内网消息处理器
 * 同一个messageType只能有一个处理器
 * 并不是处理具体的消息 而是处理某一类消息
 * 通过这个处理器再分发到具体的消息处理器
 * @param messageType
 * @returns
 */
function InnerMsgDecorator(messageType) {
    return function (target) {
        DecoratorCollector.inst.add(DecoratorType.InnerMsgHandler, target, messageType);
    };
}

/**
 * 外网消息处理器
 * 同一个messageType只能有一个处理器
 * 并不是处理具体的消息 而是处理某一类消息
 * 通过这个处理器再分发到具体的消息处理器
 * @param messageType
 * @returns
 */
function OuterMsgDecorator(messageType) {
    return function (target) {
        DecoratorCollector.inst.add(DecoratorType.OuterMsgHandler, target, messageType);
    };
}

/**
 * 客户端发给服务端需要回复的消息用这个
 * rpc消息处理器
 * 收到消息后会将回复消息发送回去
 * 优点是不会阻塞 可以在run里面随意await
 */
class AMRpcHandler {
    handle(session, message, responseType) {
        this.handleAsync(session, message, responseType);
    }
    async handleAsync(session, request, responseType) {
        try {
            let rpcId = request.rpcId;
            let instanceId = session.instanceId;
            let response = new responseType();
            try {
                await this.run(session, request, response);
            }
            catch (error) {
                coreError('{0}.run error, {1}', this.constructor.name, error.stack);
                response.error = ErrorCore.ERR_RpcFail;
                response.message = error.message;
            }
            // 等回调回来,session可以已经断开了,所以需要判断session InstanceId是否一样
            if (session.instanceId != instanceId) {
                return;
            }
            response.rpcId = rpcId; // 在这里设置rpcId是为了防止在Run中不小心修改rpcId字段
            session.Send(response);
        }
        catch (e) {
            coreError('{0}消息处理失败', this.constructor.name);
        }
    }
}

// 此文件为自动生成，请勿手工修改！
var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let _ActorResponse_Parser = class _ActorResponse_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
_ActorResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode._ActorResponse)
], _ActorResponse_Parser);
let DBCacheResponse_Parser = class DBCacheResponse_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
DBCacheResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.DBCacheResponse)
], DBCacheResponse_Parser);
let DBQueryResponse_Parser = class DBQueryResponse_Parser {
    static encode(w, msg) {
        if (msg.data != null) {
            w.uint32(26).bytes(msg.data);
        }
        w.uint32(32).uint32(msg.rpcId);
        w.uint32(40).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(50).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.data = r.bytes();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 5: {
                    msg.error = r.uint32();
                    break;
                }
                case 6: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
DBQueryResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.DBQueryResponse)
], DBQueryResponse_Parser);
let DBDeleteResponse_Parser = class DBDeleteResponse_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
DBDeleteResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.DBDeleteResponse)
], DBDeleteResponse_Parser);
let ObjectAddResponse_Parser = class ObjectAddResponse_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectAddResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectAddResponse)
], ObjectAddResponse_Parser);
let ObjectGetResponse_Parser = class ObjectGetResponse_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.instanceId);
        w.uint32(32).uint32(msg.rpcId);
        w.uint32(40).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(50).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.instanceId = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 5: {
                    msg.error = r.uint32();
                    break;
                }
                case 6: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectGetResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectGetResponse)
], ObjectGetResponse_Parser);
let ObjectLockResponse_Parser = class ObjectLockResponse_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectLockResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectLockResponse)
], ObjectLockResponse_Parser);
let ObjectRemoveResponse_Parser = class ObjectRemoveResponse_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectRemoveResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectRemoveResponse)
], ObjectRemoveResponse_Parser);
let ObjectUnLockResponse_Parser = class ObjectUnLockResponse_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectUnLockResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectUnLockResponse)
], ObjectUnLockResponse_Parser);
let G2R_GetLoginKey_Parser = class G2R_GetLoginKey_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.key);
        w.uint32(32).uint32(msg.rpcId);
        w.uint32(40).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(50).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.key = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 5: {
                    msg.error = r.uint32();
                    break;
                }
                case 6: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
G2R_GetLoginKey_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.G2R_GetLoginKey)
], G2R_GetLoginKey_Parser);
let M2G_ConnectUnit_Parser = class M2G_ConnectUnit_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.sceneInstanceId);
        w.uint32(32).uint32(msg.rpcId);
        w.uint32(40).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(50).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.sceneInstanceId = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 5: {
                    msg.error = r.uint32();
                    break;
                }
                case 6: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
M2G_ConnectUnit_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.M2G_ConnectUnit)
], M2G_ConnectUnit_Parser);
let M2G_DisconnectUnit_Parser = class M2G_DisconnectUnit_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
M2G_DisconnectUnit_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.M2G_DisconnectUnit)
], M2G_DisconnectUnit_Parser);
let M2M_UnitTransferResponse_Parser = class M2M_UnitTransferResponse_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
M2M_UnitTransferResponse_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.M2M_UnitTransferResponse)
], M2M_UnitTransferResponse_Parser);
let DBCacheRequest_Parser = class DBCacheRequest_Parser {
    static encode(w, msg) {
        w.uint32(26).bytes(msg.data);
        w.uint32(32).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.data = r.bytes();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
DBCacheRequest_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.DBCacheRequest)
], DBCacheRequest_Parser);
let DBQueryRequest_Parser = class DBQueryRequest_Parser {
    static encode(w, msg) {
        if (msg.numberKey != null) {
            w.uint32(24).int64(msg.numberKey);
        }
        if (msg.stringKey != null) {
            w.uint32(34).string(msg.stringKey);
        }
        w.uint32(40).int32(msg.typeCode);
        w.uint32(48).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.numberKey = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.stringKey = r.string();
                    break;
                }
                case 5: {
                    msg.typeCode = r.int32();
                    break;
                }
                case 6: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
DBQueryRequest_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.DBQueryRequest)
], DBQueryRequest_Parser);
let DBDeleteRequest_Parser = class DBDeleteRequest_Parser {
    static encode(w, msg) {
        if (msg.numberKey != null) {
            w.uint32(24).int64(msg.numberKey);
        }
        if (msg.stringKey != null) {
            w.uint32(34).string(msg.stringKey);
        }
        w.uint32(40).int32(msg.typeCode);
        w.uint32(48).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.numberKey = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.stringKey = r.string();
                    break;
                }
                case 5: {
                    msg.typeCode = r.int32();
                    break;
                }
                case 6: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
DBDeleteRequest_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.DBDeleteRequest)
], DBDeleteRequest_Parser);
let ObjectAddRequest_Parser = class ObjectAddRequest_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.key);
        w.uint32(32).int64(msg.instanceId);
        w.uint32(40).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.key = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.instanceId = r.int64().toNumber();
                    break;
                }
                case 5: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectAddRequest_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectAddRequest)
], ObjectAddRequest_Parser);
let ObjectGetRequest_Parser = class ObjectGetRequest_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.key);
        w.uint32(32).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.key = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectGetRequest_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectGetRequest)
], ObjectGetRequest_Parser);
let ObjectLockRequest_Parser = class ObjectLockRequest_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.key);
        w.uint32(32).int64(msg.instanceId);
        w.uint32(40).int32(msg.time);
        w.uint32(48).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.key = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.instanceId = r.int64().toNumber();
                    break;
                }
                case 5: {
                    msg.time = r.int32();
                    break;
                }
                case 6: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectLockRequest_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectLockRequest)
], ObjectLockRequest_Parser);
let ObjectRemoveRequest_Parser = class ObjectRemoveRequest_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.key);
        w.uint32(32).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.key = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectRemoveRequest_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectRemoveRequest)
], ObjectRemoveRequest_Parser);
let ObjectUnLockRequest_Parser = class ObjectUnLockRequest_Parser {
    static encode(w, msg) {
        if (msg.key != null) {
            w.uint32(24).int64(msg.key);
        }
        if (msg.oldInstanceId != null) {
            w.uint32(32).int64(msg.oldInstanceId);
        }
        if (msg.instanceId != null) {
            w.uint32(40).int64(msg.instanceId);
        }
        w.uint32(48).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.key = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.oldInstanceId = r.int64().toNumber();
                    break;
                }
                case 5: {
                    msg.instanceId = r.int64().toNumber();
                    break;
                }
                case 6: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
ObjectUnLockRequest_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.ObjectUnLockRequest)
], ObjectUnLockRequest_Parser);
let R2G_GetLoginKey_Parser = class R2G_GetLoginKey_Parser {
    static encode(w, msg) {
        w.uint32(26).string(msg.account);
        w.uint32(32).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.account = r.string();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
R2G_GetLoginKey_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.R2G_GetLoginKey)
], R2G_GetLoginKey_Parser);
let G2M_ConnectUnit_Parser = class G2M_ConnectUnit_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.sessionInstanceId);
        w.uint32(32).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.sessionInstanceId = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
G2M_ConnectUnit_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.G2M_ConnectUnit)
], G2M_ConnectUnit_Parser);
let G2M_DisconnectUnit_Parser = class G2M_DisconnectUnit_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.sessionInstanceId);
        w.uint32(32).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.sessionInstanceId = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
G2M_DisconnectUnit_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.G2M_DisconnectUnit)
], G2M_DisconnectUnit_Parser);
let M2M_UnitTransferRequest_Parser = class M2M_UnitTransferRequest_Parser {
    static encode(w, msg) {
        if (msg.oldInstanceId != null) {
            w.uint32(24).int64(msg.oldInstanceId);
        }
        if (msg.unit != null) {
            w.uint32(34).bytes(msg.unit);
        }
        for (const v of msg.entitys) {
            w.uint32(42).bytes(v);
        }
        w.uint32(48).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.oldInstanceId = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.unit = r.bytes();
                    break;
                }
                case 5: {
                    let v = r.bytes();
                    msg.entitys.push(v);
                    break;
                }
                case 6: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
M2M_UnitTransferRequest_Parser = __decorate$q([
    MessageParserDecorator(InnerMessageCoreOpcode.M2M_UnitTransferRequest)
], M2M_UnitTransferRequest_Parser);

// 此文件为自动生成，请勿手工修改！
var OuterMessageCoreOpcode;
(function (OuterMessageCoreOpcode) {
    OuterMessageCoreOpcode[OuterMessageCoreOpcode["R2C_Login"] = 2000] = "R2C_Login";
    OuterMessageCoreOpcode[OuterMessageCoreOpcode["G2C_LoginGate"] = 2002] = "G2C_LoginGate";
    OuterMessageCoreOpcode[OuterMessageCoreOpcode["G2C_Ping"] = 2004] = "G2C_Ping";
    OuterMessageCoreOpcode[OuterMessageCoreOpcode["C2G_TestPressure"] = 2006] = "C2G_TestPressure";
    OuterMessageCoreOpcode[OuterMessageCoreOpcode["C2R_Login"] = 2001] = "C2R_Login";
    OuterMessageCoreOpcode[OuterMessageCoreOpcode["C2G_LoginGate"] = 2003] = "C2G_LoginGate";
    OuterMessageCoreOpcode[OuterMessageCoreOpcode["C2G_Ping"] = 2005] = "C2G_Ping";
})(OuterMessageCoreOpcode || (OuterMessageCoreOpcode = {}));

// 此文件为自动生成，请勿手工修改！
var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let R2C_Login_Parser = class R2C_Login_Parser {
    static encode(w, msg) {
        if (msg.address != null) {
            w.uint32(26).string(msg.address);
        }
        if (msg.key != null) {
            w.uint32(32).int64(msg.key);
        }
        w.uint32(40).uint32(msg.rpcId);
        w.uint32(48).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(58).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.address = r.string();
                    break;
                }
                case 4: {
                    msg.key = r.int64().toNumber();
                    break;
                }
                case 5: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 6: {
                    msg.error = r.uint32();
                    break;
                }
                case 7: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
R2C_Login_Parser = __decorate$p([
    MessageParserDecorator(OuterMessageCoreOpcode.R2C_Login)
], R2C_Login_Parser);
let G2C_LoginGate_Parser = class G2C_LoginGate_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
        w.uint32(32).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(42).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 4: {
                    msg.error = r.uint32();
                    break;
                }
                case 5: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
G2C_LoginGate_Parser = __decorate$p([
    MessageParserDecorator(OuterMessageCoreOpcode.G2C_LoginGate)
], G2C_LoginGate_Parser);
let G2C_Ping_Parser = class G2C_Ping_Parser {
    static encode(w, msg) {
        if (msg.time != null) {
            w.uint32(24).int64(msg.time);
        }
        w.uint32(32).uint32(msg.rpcId);
        w.uint32(40).uint32(msg.error);
        if (msg.message != null) {
            w.uint32(50).string(msg.message);
        }
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.time = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                case 5: {
                    msg.error = r.uint32();
                    break;
                }
                case 6: {
                    msg.message = r.string();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
G2C_Ping_Parser = __decorate$p([
    MessageParserDecorator(OuterMessageCoreOpcode.G2C_Ping)
], G2C_Ping_Parser);
let C2G_TestPressure_Parser = class C2G_TestPressure_Parser {
    static encode(w, msg) {
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
C2G_TestPressure_Parser = __decorate$p([
    MessageParserDecorator(OuterMessageCoreOpcode.C2G_TestPressure)
], C2G_TestPressure_Parser);
let C2R_Login_Parser = class C2R_Login_Parser {
    static encode(w, msg) {
        w.uint32(26).string(msg.account);
        w.uint32(34).string(msg.password);
        w.uint32(40).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.account = r.string();
                    break;
                }
                case 4: {
                    msg.password = r.string();
                    break;
                }
                case 5: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
C2R_Login_Parser = __decorate$p([
    MessageParserDecorator(OuterMessageCoreOpcode.C2R_Login)
], C2R_Login_Parser);
let C2G_LoginGate_Parser = class C2G_LoginGate_Parser {
    static encode(w, msg) {
        w.uint32(24).int64(msg.key);
        w.uint32(32).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.key = r.int64().toNumber();
                    break;
                }
                case 4: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
C2G_LoginGate_Parser = __decorate$p([
    MessageParserDecorator(OuterMessageCoreOpcode.C2G_LoginGate)
], C2G_LoginGate_Parser);
let C2G_Ping_Parser = class C2G_Ping_Parser {
    static encode(w, msg) {
        w.uint32(24).uint32(msg.rpcId);
    }
    static decode(r, msg, length) {
        let end = length === undefined ? r.len : r.pos + length;
        while (r.pos < end) {
            const tag = r.uint32();
            switch (tag >>> 3) {
                case 3: {
                    msg.rpcId = r.uint32();
                    break;
                }
                default:
                    r.skipType(tag & 7);
                    break;
            }
        }
    }
};
C2G_Ping_Parser = __decorate$p([
    MessageParserDecorator(OuterMessageCoreOpcode.C2G_Ping)
], C2G_Ping_Parser);

/**
 * 直发消息处理器装饰器
 * @param msgType
 * @param sceneType
 * @param responseType
 * @returns
 */
function MessageHandlerDecorator(msgType, sceneType, responseType) {
    return function (msgHandlerType) {
        DecoratorCollector.inst.add(DecoratorTypeCore.MessageHandler, msgHandlerType, msgType, sceneType, responseType);
    };
}

/**
 * 挂在session上保存GatePlayerId
 * 这样就可以找到session对应的GatePlayer
 */
class SessionPlayerComponent extends Entity {
    get playerId() {
        return this._playerId;
    }
    init(playerId) {
        this._playerId = playerId;
        return this;
    }
}

// 此文件为自动生成，请勿手工修改！
var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let R2C_Login = class R2C_Login {
    constructor(args) {
        Object.assign(this, args);
    }
};
R2C_Login = __decorate$o([
    MessageDecorator(OuterMessageCoreOpcode.R2C_Login, 'Response')
], R2C_Login);
let G2C_LoginGate = class G2C_LoginGate {
    constructor(args) {
        Object.assign(this, args);
    }
};
G2C_LoginGate = __decorate$o([
    MessageDecorator(OuterMessageCoreOpcode.G2C_LoginGate, 'Response')
], G2C_LoginGate);
let G2C_Ping = class G2C_Ping {
    constructor(args) {
        Object.assign(this, args);
    }
};
G2C_Ping = __decorate$o([
    MessageDecorator(OuterMessageCoreOpcode.G2C_Ping, 'Response')
], G2C_Ping);
/**
 * 压力测试 收到这个协议的时候自定义操作 例如可以发条消息给map服
 */
let C2G_TestPressure = class C2G_TestPressure {
    constructor(args) {
        Object.assign(this, args);
    }
};
C2G_TestPressure = __decorate$o([
    MessageDecorator(OuterMessageCoreOpcode.C2G_TestPressure, 'Message')
], C2G_TestPressure);
/**
 * 客户端发消息给Realm服 请求gate地址
 */
let C2R_Login = class C2R_Login {
    constructor(args) {
        Object.assign(this, args);
    }
};
C2R_Login = __decorate$o([
    ResponseTypeDecorator(R2C_Login),
    MessageDecorator(OuterMessageCoreOpcode.C2R_Login, 'Request')
], C2R_Login);
let C2G_LoginGate = class C2G_LoginGate {
    constructor(args) {
        Object.assign(this, args);
    }
};
C2G_LoginGate = __decorate$o([
    ResponseTypeDecorator(G2C_LoginGate),
    MessageDecorator(OuterMessageCoreOpcode.C2G_LoginGate, 'Request')
], C2G_LoginGate);
let C2G_Ping = class C2G_Ping {
    constructor(args) {
        Object.assign(this, args);
    }
};
C2G_Ping = __decorate$o([
    ResponseTypeDecorator(G2C_Ping),
    MessageDecorator(OuterMessageCoreOpcode.C2G_Ping, 'Request')
], C2G_Ping);

class GatePlayerHelper {
    /**
     * 通过session获取GatePlayer
     * @param session
     * @returns
     */
    static getGatePlayerFromSession(session) {
        let playerComponent = session.domainScene().getComponent(GatePlayerComponent);
        let gatePlayerId = session.getComponent(SessionPlayerComponent).playerId;
        let gatePlayer = playerComponent.getChild(GatePlayer, gatePlayerId);
        return gatePlayer;
    }
    /**
     * 只有在连接unit成功后才会有unitId
     * @param session
     * @returns
     */
    static getUnitIdFromSession(session) {
        let gatePlayer = this.getGatePlayerFromSession(session);
        return gatePlayer.getComponent(GatePlayerUnitComponent).unitId;
    }
    /**
     * 给GatePlayer添加引用
     * @param gatePlayer
     */
    static addRef(gatePlayer) {
        gatePlayer.ref++;
        coreLog('GatePlayerHelper addRef: ref={0}', gatePlayer.ref);
    }
    /**
     * 给GatePlayer减少引用
     * @param gatePlayer
     * @returns
     */
    static subRef(gatePlayer) {
        gatePlayer.ref--;
        coreLog('GatePlayerHelper subRef: ref={0}', gatePlayer.ref);
        this.tryRemoveGatePlayer(gatePlayer);
    }
    static async tryRemoveGatePlayer(gatePlayer) {
        if (gatePlayer.isDisposed) {
            return;
        }
        if (gatePlayer.ref > 0) {
            return;
        }
        let ret = await DBHelper.save(gatePlayer);
        if (!ret) {
            await TimerMgr.getInst().waitAsync(10 * 1000);
            this.tryRemoveGatePlayer(gatePlayer);
            return;
        }
        if (gatePlayer.isDisposed) {
            return;
        }
        // 存数据库途中 又有新的session引用了
        if (gatePlayer.ref > 0) {
            return;
        }
        {
            coreLog(`GatePlayer ${gatePlayer.account} 被销毁`);
        }
        gatePlayer.getParent(GatePlayerComponent).removePlayer(gatePlayer.account);
        gatePlayer.dispose();
    }
}

class LoginHelper {
    /**
     * 踢掉上一个session 用新的session
     * 既是踢掉上一个session，又是设置新的session
     * @param player
     */
    static kickSession(player, newSession) {
        let playerSessionCom = player.getComponent(PlayerSessionComponent);
        let oldSessionInstanceId = playerSessionCom.sessionInstanceId;
        playerSessionCom.sessionInstanceId = newSession.instanceId;
        if (oldSessionInstanceId == null) {
            return;
        }
        let oldSession = Root.getInst().get(oldSessionInstanceId);
        if (oldSession == null) {
            return;
        }
        if (oldSession.isDisposed) {
            return;
        }
        oldSession.Error = SocketCloseCode.OtherLogin;
        oldSession.dispose();
    }
}

/**
 * 每当有一个session连接gate，就添加这个组件给session，用于引用GatePlayer
 * 当session断开时，就销毁这个组件，用于解除引用
 * 这样GatePlayer在有引用的时候就不会被销毁
 */
class SessionGatePlayerRefCom extends Entity {
    init(gatePlayer) {
        this._gatePlayerId = gatePlayer.id;
        GatePlayerHelper.addRef(gatePlayer);
    }
    destroy() {
        let gatePlayer = this.domainScene().getComponent(GatePlayerComponent).getChild(GatePlayer, this._gatePlayerId);
        GatePlayerHelper.subRef(gatePlayer);
    }
}

/**
 * 用于记录账号的登录状态
 * 防止重复发送登录请求
 */
class SessionLoginLockComponent extends Entity {
}

var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let C2G_LoginGateHandler = class C2G_LoginGateHandler extends AMRpcHandler {
    async run(session, request, response) {
        let scene = session.domainScene();
        let account = scene.getComponent(GateSessionKeyComponent).getAccount(request.key);
        if (account == null) {
            response.error = ErrorCore.ERR_ConnectGateKeyError;
            response.message = "Gate key验证失败!";
            return;
        }
        session.removeComponent(SessionAcceptTimeoutComponent);
        if (session.getComponent(SessionLoginLockComponent)) {
            response.error = ErrorCore.Login_RepeatRequestGate;
            coreWarn(`玩家重复发送登录请求 account= ${account}`);
            return;
        }
        // 走到这里就已经代表玩家登陆成功了
        session.addComponent(SessionLoginLockComponent);
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.C2G_LoginGate, account);
        try {
            let playerComponent = scene.getComponent(GatePlayerComponent);
            let player = await playerComponent.getPlayer(account);
            if (player == null) {
                response.error = ErrorCore.ERR_DBErr;
                return;
            }
            // 回来以后再次判断一下session是否已经被销毁了
            if (session.isDisposed) {
                // 这里先加后减是为了调用gateplayer离线
                GatePlayerHelper.addRef(player);
                GatePlayerHelper.subRef(player);
                return;
            }
            // 先给player添加引用 避免被销毁
            session.addComponent(SessionGatePlayerRefCom).init(player);
            // 踢掉之前的session
            LoginHelper.kickSession(player, session);
            session.addComponent(SessionPlayerComponent).init(player.id);
            // 给session添加一个mailbox 这样就可以接收来自其他scene的消息了
            session.addComponent(MailBoxComponent).init(MailboxType.GateSession);
        }
        finally {
            lock.dispose();
        }
    }
};
C2G_LoginGateHandler = __decorate$n([
    MessageHandlerDecorator(C2G_LoginGate, SceneTypeCore.Gate, G2C_LoginGate)
], C2G_LoginGateHandler);

var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let C2G_PingHandler = class C2G_PingHandler extends AMRpcHandler {
    async run(session, request, response) {
        response.time = TimeHelper.serverNow();
    }
};
C2G_PingHandler = __decorate$m([
    MessageHandlerDecorator(C2G_Ping, SceneTypeCore.Gate, G2C_Ping)
], C2G_PingHandler);

class ActorMessageDispatcherInfo {
    constructor(sceneType, imActorHandler, responseType) {
        this.sceneType = sceneType;
        this.actorHandler = imActorHandler;
        this.responseType = responseType;
    }
}
/**
 * 不是直接发送到目的地的消息都是通过这个类分发
 * 比如客户端发送给map场景的消息 就需要这个
 * 如果是客户端发给gate的就不需要这个 因为gate直接与客户端通信 不需要转发
 * 有多个处理器也是挺合理的
 */
class ActorMessageDispatcherMgr extends Singleton {
    constructor() {
        super(...arguments);
        this.handlers = new Map;
    }
    awake() {
        this.load();
    }
    destroy() {
        this.handlers.clear();
    }
    registerHandler(msgCtor, handler) {
        if (!this.handlers.has(msgCtor)) {
            this.handlers.set(msgCtor, new Array());
        }
        this.handlers.get(msgCtor).push(handler);
    }
    load() {
        let list = DecoratorCollector.inst.get(DecoratorType.ActorMessageHandler);
        for (const args of list) {
            let msgHandlerType = args[0];
            let msgType = args[1];
            let sceneType = args[2];
            let responseType = args[3];
            let handler = new msgHandlerType();
            let messageDispatcherInfo = new ActorMessageDispatcherInfo(sceneType, handler, responseType);
            this.registerHandler(msgType, messageDispatcherInfo);
        }
    }
    async handleAsync(entity, fromProcess, message) {
        try {
            let actions = this.handlers.get(message.constructor);
            if (!actions) {
                throw new Error(`not found message handler: ${message.constructor}`);
            }
            let sceneType = entity.domainScene().sceneType;
            for (const messageDispatcherInfo of actions) {
                if (messageDispatcherInfo.sceneType != sceneType) {
                    continue;
                }
                await messageDispatcherInfo.actorHandler.handleAsync(entity, fromProcess, message, messageDispatcherInfo.responseType);
            }
        }
        catch (e) {
            coreError('ActorMessageDispatcherMgr.handle error, msg= {0}, {1}', message.constructor.name, e.stack);
        }
    }
    handleSync(entity, fromProcess, message) {
        let actions = this.handlers.get(message.constructor);
        if (!actions) {
            throw new Error(`not found message handler: ${message.constructor}`);
        }
        let sceneType = entity.domainScene().sceneType;
        for (const messageDispatcherInfo of actions) {
            if (messageDispatcherInfo.sceneType != sceneType) {
                continue;
            }
            messageDispatcherInfo.actorHandler.handleSync(entity, fromProcess, message, messageDispatcherInfo.responseType);
        }
    }
}

/**
 * 收到rpc消息的处理
 */
class ActorRequestHandleHelper {
    static handleActorRequest(actorId, iActorRequest) {
        try {
            let objectPool = ObjectPool.getInst();
            let instanceIdStruct = objectPool.fetch(InstanceIdStruct);
            instanceIdStruct.initArgs1(actorId);
            let fromProcess = instanceIdStruct.Process;
            instanceIdStruct.Process = Options.getInst().process;
            instanceIdStruct.updateResult();
            let realActorId = instanceIdStruct.ToLong();
            objectPool.recycle(instanceIdStruct);
            let entity = Root.getInst().get(realActorId);
            if (entity == null) {
                let response = ActorHelper.createResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);
                this.reply(fromProcess, response);
                return;
            }
            let mailBoxComponent = entity.getComponent(MailBoxComponent);
            if (mailBoxComponent == null) {
                coreWarn('actor not found mailbox: {0} {1} {2}', entity.constructor.name, realActorId, iActorRequest.constructor.name);
                let response = ActorHelper.createResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);
                this.reply(fromProcess, response);
                return;
            }
            switch (mailBoxComponent.MailboxType) {
                case MailboxType.MessageDispatcher: {
                    mailBoxComponent.addReq(iActorRequest, fromProcess);
                    this.handleReqQueue(mailBoxComponent, realActorId);
                    break;
                }
                case MailboxType.UnOrderMessageDispatcher: {
                    ActorMessageDispatcherMgr.getInst().handleAsync(entity, fromProcess, iActorRequest);
                    break;
                }
                case MailboxType.GateSession:
                default:
                    throw new Error(`no mailboxtype: ${mailBoxComponent.MailboxType} ${iActorRequest.constructor.name}`);
            }
        }
        catch (e) {
            coreError('handleActorRequest error: {0}', e.stack);
        }
    }
    static handleActorLocationMessage(actorId, iActorRequest) {
        try {
            let objectPool = ObjectPool.getInst();
            let instanceIdStruct = objectPool.fetch(InstanceIdStruct);
            instanceIdStruct.initArgs1(actorId);
            let fromProcess = instanceIdStruct.Process;
            instanceIdStruct.Process = Options.getInst().process;
            instanceIdStruct.updateResult();
            let realActorId = instanceIdStruct.ToLong();
            objectPool.recycle(instanceIdStruct);
            let entity = Root.getInst().get(realActorId);
            if (entity == null) {
                let response = ActorHelper.createResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);
                this.reply(fromProcess, response);
                return;
            }
            let mailBoxComponent = entity.getComponent(MailBoxComponent);
            if (mailBoxComponent == null) {
                coreWarn('actor not found mailbox: {0} {1} {2}', entity.constructor.name, realActorId, iActorRequest.constructor.name);
                let response = ActorHelper.createResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);
                this.reply(fromProcess, response);
                return;
            }
            switch (mailBoxComponent.MailboxType) {
                case MailboxType.MessageDispatcher: {
                    ActorMessageDispatcherMgr.getInst().handleSync(entity, fromProcess, iActorRequest);
                    break;
                }
                case MailboxType.UnOrderMessageDispatcher: {
                    ActorMessageDispatcherMgr.getInst().handleSync(entity, fromProcess, iActorRequest);
                    break;
                }
                case MailboxType.GateSession:
                default:
                    throw new Error(`no mailboxtype: ${mailBoxComponent.MailboxType} ${iActorRequest.constructor.name}`);
            }
        }
        catch (e) {
            coreError('handleActorLocationMessage error: {0}', e.stack);
        }
    }
    static reply(fromProcess, response) {
        {
            // 返回消息是同一个进程
            if (fromProcess == Options.getInst().process) {
                if (response.error == null) {
                    response.error = ErrorCore.ERR_Success;
                }
                ActorMessageSenderMgr.getInst().handleActorResponse(response);
                return;
            }
        }
        try {
            let replySession = NetInnerComponent.inst.get(fromProcess);
            replySession.Send(response);
        }
        catch (e) {
            coreError('ActorRequestHandleHelper.reply error: {0}', e.stack);
        }
    }
    static async handleReqQueue(mailBoxCom, realActorId) {
        try {
            if (mailBoxCom.isDisposed) {
                return;
            }
            if (mailBoxCom.isHandling) {
                return;
            }
            mailBoxCom.isHandling = true;
            let item = mailBoxCom.getReq();
            let entity = mailBoxCom.parent;
            while (item != null) {
                // 这里代表entity已经被销毁了
                if (entity.instanceId != realActorId) {
                    let response = ActorHelper.createResponse(item.req, ErrorCore.ERR_NotFoundActor);
                    this.reply(item.fromProcess, response);
                    item.dispose();
                    break;
                }
                let fromProcess = item.fromProcess;
                let req = item.req;
                item.dispose();
                await ActorMessageDispatcherMgr.getInst().handleAsync(entity, fromProcess, req);
                if (mailBoxCom.isDisposed) {
                    break;
                }
                item = mailBoxCom.getReq();
            }
        }
        catch (e) {
            coreError('handleReqQueue error: {0}', e.stack);
        }
        finally {
            mailBoxCom.isHandling = false;
            mailBoxCom.clearItem();
        }
    }
}

/**
 * 这个一般是服务端不同scene之间的消息处理器
 * 需要回应的actor消息处理器基类
 * 不会阻塞
 */
class AMActorRpcHandler {
    async handleAsync(entity, fromProcess, request, responseType) {
        let rpcId = request.rpcId;
        this._fromProcess = fromProcess;
        let response = new responseType();
        try {
            await this.run(entity, request, response);
        }
        catch (error) {
            coreError('{0} run error: {1}', this.constructor.name, error.stack);
            response.error = ErrorCore.ERR_RpcFail;
            response.message = error.message;
        }
        response.rpcId = rpcId; // 在这里设置rpcId是为了防止在Run中不小心修改rpcId字段
        ActorRequestHandleHelper.reply(fromProcess, response);
        this._fromProcess = 0;
    }
}

/**
 * actor消息处理器装饰器
 * @param msgType
 * @param sceneType
 * @param responseType
 * @returns
 */
function ActorMessageHandlerDecorator(msgType, sceneType, responseType) {
    return function (msgHandlerType) {
        DecoratorCollector.inst.add(DecoratorType.ActorMessageHandler, msgHandlerType, msgType, sceneType, responseType);
    };
}

var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let R2G_GetLoginKeyHandler = class R2G_GetLoginKeyHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        let key = scene.getComponent(GateSessionKeyComponent).newKey(request.account);
        response.key = key;
    }
};
R2G_GetLoginKeyHandler = __decorate$l([
    ActorMessageHandlerDecorator(R2G_GetLoginKey, SceneTypeCore.Gate, G2R_GetLoginKey)
], R2G_GetLoginKeyHandler);

/**
 * 客户端发送给unit的rpc消息用这个处理器
 * 注意 这个会堵塞消息 尽量不要run里面用await
 * 甚至会阻塞发送端
 */
class AMActorLocationRpcHandler {
    async handleAsync(unit, fromProcess, message, responseType) {
        let request = message;
        let rpcId = request.rpcId;
        let response = new responseType();
        try {
            await this.run(unit, request, response);
        }
        catch (error) {
            coreError('{0}.run error, {1}', this.constructor.name, error.stack);
            response.error = ErrorCore.ERR_RpcFail;
            response.message = error.message;
        }
        response.rpcId = rpcId; // 在这里设置rpcId是为了防止在Run中不小心修改rpcId字段
        ActorRequestHandleHelper.reply(fromProcess, response);
    }
}

var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * unit在map的时候借助这个组件找到对应session
 */
let UnitGateComponent = class UnitGateComponent extends Entity {
    setSessionActorId(id) {
        this.gateSessionActorId = id;
    }
};
UnitGateComponent = __decorate$k([
    Transfer
], UnitGateComponent);

/**
 * location代理组件
 * 用于跨进程的location操作
 * todo: 改成单例好一点
 */
class LocationProxyComponent extends Entity {
    awake() {
        LocationProxyComponent.inst = this;
    }
    destroy() {
        LocationProxyComponent.inst = null;
    }
    getLocationSceneId() {
        let sceneInfo = SceneMgr.getInst().getFirstSceneByType("Location");
        return sceneInfo.instanceId;
    }
    async lock(key, instanceId, time = 60000) {
        let actorId = this.getLocationSceneId();
        await ActorMsgHelper.call(actorId, new ObjectLockRequest({ key: key, instanceId: instanceId, time: time }));
    }
    /**
     * 获取key对应的instanceId
     * @param key
     * @returns
     */
    async get(key) {
        if (key == 0) {
            throw new Error("get location key 0");
        }
        let actorId = this.getLocationSceneId();
        let response = await ActorMsgHelper.call(actorId, new ObjectGetRequest({ key: key }), ObjectGetResponse);
        return response.instanceId;
    }
    async unLock(key, oldInstanceId, instanceId) {
        let actorId = this.getLocationSceneId();
        await ActorMsgHelper.call(actorId, new ObjectUnLockRequest({
            key: key,
            oldInstanceId: oldInstanceId,
            instanceId: instanceId
        }));
    }
    async add(key, instanceId) {
        let actorId = this.getLocationSceneId();
        await ActorMsgHelper.call(actorId, new ObjectAddRequest({
            key: key,
            instanceId: instanceId
        }));
    }
    async remove(key) {
        let actorId = this.getLocationSceneId();
        await ActorMsgHelper.call(actorId, new ObjectRemoveRequest({
            key: key,
        }));
    }
}

class UnitRemoveHelper {
    static remove(unit) {
        LocationProxyComponent.inst.remove(unit.id);
    }
}

var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * unit的引用组件
 * 当引用大于0的时候 不允许被销毁
 * 比如进入战斗 必须等战斗结束再销毁
 */
let UnitRefComponent = class UnitRefComponent extends Entity {
    constructor() {
        super(...arguments);
        this._ref = 0;
    }
    addRef() {
        this._ref++;
        coreLog(`unit引用增加, unitId=${this.parent.id}, ref=${this._ref}`);
    }
    subRef() {
        this._ref--;
        coreLog(`unit引用减少, unitId=${this.parent.id}, ref=${this._ref}`);
        this.tryDispose();
    }
    async tryDispose() {
        if (this.isDisposed) {
            return;
        }
        // 等个3秒 如果又增加了引用 就不销毁了
        await TimerMgr.getInst().waitAsync(3000);
        if (this._ref > 0) {
            return;
        }
        if (this.parent == null) {
            coreLog(`UnitRefComponent: unit已经销毁, 不再保存`);
            return;
        }
        if (this.parent.isDisposed) {
            coreLog(`UnitRefComponent: unit 已经销毁2, 不再保存`);
            return;
        }
        let ret = await DBHelper.save(this.parent);
        // 保存失败 等待一段时间再试
        if (!ret) {
            await TimerMgr.getInst().waitAsync(10 * 1000);
            this.tryDispose();
            return;
        }
        // 异步回来可能又增加了引用
        if (this._ref > 0) {
            return;
        }
        UnitRemoveHelper.remove(this.parent);
        coreLog(`unit离线, unitId=${this.parent.id}`);
        this.parent.dispose();
    }
};
UnitRefComponent = __decorate$j([
    Transfer
], UnitRefComponent);

var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let G2M_ConnectUnitHandler = class G2M_ConnectUnitHandler extends AMActorLocationRpcHandler {
    async run(unit, request, response) {
        coreLog(`请求连接在map的unit, unitId=${unit.id}}`);
        // 这样就更新了对应的session,从而可以在mapscene下发消息给客户端
        unit.getComponent(UnitGateComponent).setSessionActorId(request.sessionInstanceId);
        unit.getComponent(UnitRefComponent).addRef();
        response.sceneInstanceId = unit.domainScene().instanceId;
    }
};
G2M_ConnectUnitHandler = __decorate$i([
    ActorMessageHandlerDecorator(G2M_ConnectUnit, SceneTypeCore.Map, M2G_ConnectUnit)
], G2M_ConnectUnitHandler);

var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * session被销毁就会发送消息与unit断开连接
 */
let G2M_DisconnectUnitHandler = class G2M_DisconnectUnitHandler extends AMActorLocationRpcHandler {
    async run(unit, request, response) {
        coreLog(`收到G2M_DisconnectUnit, unitId=${unit.id}`);
        let unitGateCom = unit.getComponent(UnitGateComponent);
        unit.getComponent(UnitRefComponent).subRef();
        if (unitGateCom.gateSessionActorId != request.sessionInstanceId) {
            coreWarn(`sessionInstanceId不匹配, unitId=${unit.id}, sessionInstanceId=${request.sessionInstanceId}, unitGateCom.gateSessionActorId=${unitGateCom.gateSessionActorId}`);
            return;
        }
        unitGateCom.setSessionActorId(0);
    }
};
G2M_DisconnectUnitHandler = __decorate$h([
    ActorMessageHandlerDecorator(G2M_DisconnectUnit, SceneTypeCore.Map, M2G_DisconnectUnit)
], G2M_DisconnectUnitHandler);

var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let M2M_UnitTransferRequestHandler = class M2M_UnitTransferRequestHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        let unitComponent = scene.getComponent(UnitComponent);
        let time1;
        {
            time1 = Date.now();
        }
        let serializeMgr = ObjectSerializeMgr.getInst();
        let unit;
        let isSameMachine = ProcessMgr.getInst().processIdIsInMachine(this._fromProcess);
        if (isSameMachine) {
            unit = serializeMgr.deserializeSameMachine(request.unit);
            unitComponent.addChild(unit);
            for (let bytes of request.entitys) {
                unit.addComponent(serializeMgr.deserializeSameMachine(bytes));
            }
        }
        else {
            unit = serializeMgr.deserialize(request.unit);
            unitComponent.addChild(unit);
            for (let bytes of request.entitys) {
                unit.addComponent(serializeMgr.deserialize(bytes));
            }
        }
        {
            let cost = Date.now() - time1;
            if (cost > 1) {
                coreWarn(`transfer deserialize cost time=${cost}ms, 请考虑优化!`);
            }
        }
        unit.addComponent(MailBoxComponent);
        // 解锁location，可以接收发给Unit的消息
        await LocationProxyComponent.inst.unLock(unit.id, request.oldInstanceId, unit.instanceId);
        coreLog(`unit传送完成, unitId=${unit.id}`);
        EventSystem.getInst().publish(scene, AfterUnitTransfer.create({ unit: unit }));
    }
};
M2M_UnitTransferRequestHandler = __decorate$g([
    ActorMessageHandlerDecorator(M2M_UnitTransferRequest, SceneTypeCore.Map, M2M_UnitTransferResponse)
], M2M_UnitTransferRequestHandler);

var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * 玩家账号
 */
let DBAccount = class DBAccount {
};
DBAccount = __decorate$f([
    DBWithKey('account', false, 1000)
], DBAccount);

class LoginMgr extends Singleton {
    setAccountInspector(inspector) {
        this._accountInspector = inspector;
    }
    checkAccount(account, password) {
        if (this._accountInspector == null) {
            return ErrorCore.ERR_Success;
        }
        return this._accountInspector.run(account, password);
    }
    setCreateNotExistAccount(create) {
        this._createNotExistAccount = create;
    }
    getCreateNotExistAccount() {
        return this._createNotExistAccount;
    }
}

class RealmGateAddressHelper {
    static getGate(account) {
        let sceneMgr = SceneMgr.getInst();
        let sceneInfos = sceneMgr.getSceneByType(SceneTypeCore.Gate);
        let n = JsHelper.modeString(account, sceneInfos.length);
        coreLog(`${account} 网关=${n}`);
        return sceneInfos[n];
    }
}

var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let C2R_LoginHandler = class C2R_LoginHandler extends AMRpcHandler {
    async run(session, request, response) {
        // 检查账号密码
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.CheckAccount, request.account);
        try {
            let ret = await this.checkAccount(session, request, response);
            if (ret != ErrorCore.ERR_Success) {
                response.error = ret;
                return;
            }
            let config = RealmGateAddressHelper.getGate(request.account);
            // 向gate请求一个key,客户端可以拿着这个key连接gate
            let g2rGetLoginKey = await ActorMsgHelper.call(config.instanceId, new R2G_GetLoginKey({
                account: request.account,
            }), G2R_GetLoginKey);
            if (g2rGetLoginKey.error != ErrorCore.ERR_Success) {
                response.error = g2rGetLoginKey.error;
                return;
            }
            response.key = g2rGetLoginKey.key;
            response.address = config.outerAddress.toString();
        }
        finally {
            lock.dispose();
        }
    }
    async checkAccount(session, request, response) {
        let loginMgr = LoginMgr.getInst();
        let errorCode = loginMgr.checkAccount(request.account, request.password);
        if (errorCode != ErrorCore.ERR_Success) {
            return errorCode;
        }
        let [err, result] = await DBHelper.query(DBAccount, request.account);
        if (err != ErrorCore.ERR_Success) {
            return err;
        }
        let dbAccount = result;
        // 账号不存在,则创建账号
        if (loginMgr.getCreateNotExistAccount()) {
            if (dbAccount == null) {
                dbAccount = new DBAccount();
                dbAccount.account = request.account;
                dbAccount.password = request.password;
                let ret = await DBHelper.save(dbAccount);
                if (!ret) {
                    return ErrorCore.ERR_ActorTimeout;
                }
                return ErrorCore.ERR_Success;
            }
        }
        if (!dbAccount) {
            return ErrorCore.Login_AccountNotExist;
        }
        if (dbAccount.password != request.password) {
            return ErrorCore.Login_PasswordError;
        }
        return ErrorCore.ERR_Success;
    }
};
C2R_LoginHandler = __decorate$e([
    MessageHandlerDecorator(C2R_Login, SceneTypeCore.Realm, R2C_Login)
], C2R_LoginHandler);

var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ObjectAddRequestHandler = class ObjectAddRequestHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        await scene.getComponent(LocationComponent).add(request.key, request.instanceId);
    }
};
ObjectAddRequestHandler = __decorate$d([
    ActorMessageHandlerDecorator(ObjectAddRequest, SceneTypeCore.Location, ObjectAddResponse)
], ObjectAddRequestHandler);

var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ObjectGetRequestHandler = class ObjectGetRequestHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        let instanceId = await scene.getComponent(LocationComponent).get(request.key);
        if (instanceId == null) {
            instanceId = 0;
        }
        response.instanceId = instanceId;
    }
};
ObjectGetRequestHandler = __decorate$c([
    ActorMessageHandlerDecorator(ObjectGetRequest, SceneTypeCore.Location, ObjectGetResponse)
], ObjectGetRequestHandler);

var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ObjectLockRequestHandler = class ObjectLockRequestHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        await scene.getComponent(LocationComponent).lock(request.key, request.instanceId, request.time);
    }
};
ObjectLockRequestHandler = __decorate$b([
    ActorMessageHandlerDecorator(ObjectLockRequest, SceneTypeCore.Location, ObjectLockResponse)
], ObjectLockRequestHandler);

var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ObjectRemoveRequestHandler = class ObjectRemoveRequestHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        await scene.getComponent(LocationComponent).remove(request.key);
    }
};
ObjectRemoveRequestHandler = __decorate$a([
    ActorMessageHandlerDecorator(ObjectRemoveRequest, SceneTypeCore.Location, ObjectRemoveResponse)
], ObjectRemoveRequestHandler);

var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ObjectUnLockRequestHandler = class ObjectUnLockRequestHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        scene.getComponent(LocationComponent).unLock(request.key, request.oldInstanceId, request.instanceId);
    }
};
ObjectUnLockRequestHandler = __decorate$9([
    ActorMessageHandlerDecorator(ObjectUnLockRequest, SceneTypeCore.Location, ObjectUnLockResponse)
], ObjectUnLockRequestHandler);

var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DBCacheRequestHandler = class DBCacheRequestHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        let cacheComponentMgr = scene.getComponent(DBCacheComponentMgr);
        let isSameMachine = ProcessMgr.getInst().processIdIsInMachine(this._fromProcess);
        let obj = isSameMachine ? ObjectSerializeMgr.getInst().deserializeSameMachine(request.data) :
            ObjectSerializeMgr.getInst().deserialize(request.data);
        if (!obj.constructor) {
            coreError(`obj.constructor is null`);
            response.error = ErrorCore.ERR_Exception;
            return;
        }
        // coreLog(`db缓存解析出类型=${obj.constructor.name}`);
        // MsgPrinter.getInst().print(obj, 'db缓存解析出内容');
        let cacheCom = cacheComponentMgr.getCacheCom(obj.constructor);
        {
            if (cacheCom == null) {
                // coreError(`cacheCom is null, type=${obj.constructor.name}`);
                response.error = ErrorCore.ERR_Exception;
                return;
            }
        }
        cacheCom.save(obj);
    }
};
DBCacheRequestHandler = __decorate$8([
    ActorMessageHandlerDecorator(DBCacheRequest, SceneTypeCore.DBCache, DBCacheResponse)
], DBCacheRequestHandler);

var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DBDeleteRequestHandler = class DBDeleteRequestHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        let cacheComponentMgr = scene.getComponent(DBCacheComponentMgr);
        let objectSerializeMgr = ObjectSerializeMgr.getInst();
        let type = objectSerializeMgr.getType(request.typeCode);
        let cacheCom = cacheComponentMgr.getCacheCom(type);
        await cacheCom.delete(request.numberKey || request.stringKey);
    }
};
DBDeleteRequestHandler = __decorate$7([
    ActorMessageHandlerDecorator(DBDeleteRequest, SceneTypeCore.DBCache, DBDeleteResponse)
], DBDeleteRequestHandler);

var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DBQueryRequestHandler = class DBQueryRequestHandler extends AMActorRpcHandler {
    async run(scene, request, response) {
        let cacheComponentMgr = scene.getComponent(DBCacheComponentMgr);
        let objectSerializeMgr = ObjectSerializeMgr.getInst();
        let type = objectSerializeMgr.getType(request.typeCode);
        let cacheCom = cacheComponentMgr.getCacheCom(type);
        let obj = await cacheCom.query(request.numberKey || request.stringKey);
        if (obj != null) {
            let isSameMachine = ProcessMgr.getInst().processIdIsInMachine(this._fromProcess);
            response.data = isSameMachine ? objectSerializeMgr.serializeSameMachine(obj) : objectSerializeMgr.serialize(obj);
            // coreLog(`db 查询到类型=${obj.constructor.name}`)
            // MsgPrinter.getInst().print(obj, '查询到内容');
        }
        else {
            coreLog(`db 没查询到类型typecode=${request.typeCode}`);
        }
    }
};
DBQueryRequestHandler = __decorate$6([
    ActorMessageHandlerDecorator(DBQueryRequest, SceneTypeCore.DBCache, DBQueryResponse)
], DBQueryRequestHandler);

/**
 * 收到非rpc消息的处理
 */
class ActorMessageHandleHelper {
    static handleActorMessage(actorId, iActorMessage) {
        let objectPool = ObjectPool.getInst();
        let instanceIdStruct = objectPool.fetch(InstanceIdStruct);
        instanceIdStruct.initArgs1(actorId);
        let fromProcess = instanceIdStruct.Process;
        instanceIdStruct.Process = Options.getInst().process;
        instanceIdStruct.updateResult();
        let realActorId = instanceIdStruct.ToLong();
        objectPool.recycle(instanceIdStruct);
        let entity = Root.getInst().get(realActorId);
        if (entity == null) {
            // 找不到是正常的 可能entity已经销毁了
            // 消息不处理就行了
            return;
        }
        let mailBoxComponent = entity.getComponent(MailBoxComponent);
        if (mailBoxComponent == null) {
            coreError('actor not found mailbox, entityType: {0}, msg= {1}', entity.constructor.name, iActorMessage.constructor.name);
            return;
        }
        switch (mailBoxComponent.MailboxType) {
            case MailboxType.MessageDispatcher: {
                ActorMessageDispatcherMgr.getInst().handleSync(entity, fromProcess, iActorMessage);
                break;
            }
            case MailboxType.UnOrderMessageDispatcher: {
                ActorMessageDispatcherMgr.getInst().handleSync(entity, fromProcess, iActorMessage);
                break;
            }
            case MailboxType.GateSession: {
                if (entity instanceof Session) {
                    // 发送给客户端
                    entity.Send(iActorMessage);
                }
                break;
            }
            default:
                throw new Error(`no mailboxtype: ${mailBoxComponent.MailboxType} ${iActorMessage.constructor.name}`);
        }
    }
}

var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ActorMessageHandler = class ActorMessageHandler {
    run(actorId, msg) {
        ActorMessageHandleHelper.handleActorMessage(actorId, msg);
    }
};
ActorMessageHandler = __decorate$5([
    InnerMsgDecorator(MessageTypeCore.ActorMessage)
], ActorMessageHandler);

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ActorRequestHandler = class ActorRequestHandler {
    run(actorId, msg) {
        ActorRequestHandleHelper.handleActorRequest(actorId, msg);
    }
};
ActorRequestHandler = __decorate$4([
    InnerMsgDecorator(MessageTypeCore.ActorRequest),
    InnerMsgDecorator(MessageTypeCore.ActorLocationRequest)
], ActorRequestHandler);
let ActorLocationMessageHandler$1 = class ActorLocationMessageHandler {
    run(actorId, msg) {
        ActorRequestHandleHelper.handleActorLocationMessage(actorId, msg);
    }
};
ActorLocationMessageHandler$1 = __decorate$4([
    InnerMsgDecorator(MessageTypeCore.ActorLocationMessage)
], ActorLocationMessageHandler$1);

class ActorResponseHandleHelper {
    static handleActorResponse(response) {
        // 没有发送error，就是成功了
        if (response.error == null) {
            response.error = ErrorCore.ERR_Success;
        }
        ActorMessageSenderMgr.getInst().handleActorResponse(response);
    }
}

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ActorResponseHandler = class ActorResponseHandler {
    run(actorId, msg) {
        ActorResponseHandleHelper.handleActorResponse(msg);
    }
};
ActorResponseHandler = __decorate$3([
    InnerMsgDecorator(MessageTypeCore.ActorResponse),
    InnerMsgDecorator(MessageTypeCore.ActorLocationResponse)
], ActorResponseHandler);

class ActorLocationSender extends Entity {
    constructor() {
        super(...arguments);
        this.ActorId = 0;
        // 最近接收或者发送消息的时间
        this.LastSendOrRecvTime = 0;
        this.Error = 0;
        this._reqQueue = [];
        this.isSending = false;
    }
    awake() {
        this.LastSendOrRecvTime = TimeHelper.serverNow();
        this.ActorId = 0;
        this.Error = 0;
    }
    destroy() {
        this.LastSendOrRecvTime = 0;
        this.ActorId = 0;
        this.Error = 0;
    }
    addReq(request) {
        this._reqQueue.push(request);
    }
    getReq() {
        return this._reqQueue.shift();
    }
}

/**
 * 通过unitId向unit发送消息
 * 发送的时候通过id向location查询instanceId
 * 然后向instanceId所在进程发送消息
 * todo 改成单例 用对象池缓存item
 */
class ActorLocationSenderComponent extends Entity {
    constructor() {
        super(...arguments);
        this.TIMEOUT_TIME = 60 * 1000;
    }
    awake() {
        ActorLocationSenderComponent.inst = this;
        this.CheckTimer = TimerMgr.getInst().newRepeatedTimer(10 * 1000, this.check.bind(this));
    }
    destroy() {
        ActorLocationSenderComponent.inst = null;
        TimerMgr.getInst().remove(this.CheckTimer);
    }
    check() {
        let list = [];
        let timeNow = TimeHelper.serverNow();
        for (let [key, value] of this.children) {
            let actorLocationMessageSender = value;
            if (timeNow > actorLocationMessageSender.LastSendOrRecvTime + this.TIMEOUT_TIME) {
                list.push(key);
            }
        }
        for (let id of list) {
            this.remove(id);
        }
    }
    getOrCreate(id) {
        let actorLocationSender = this.children.get(id);
        if (actorLocationSender) {
            return actorLocationSender;
        }
        actorLocationSender = this.addChildWithId(ActorLocationSender, id);
        return actorLocationSender;
    }
    remove(id) {
        let actorMessageSender = this.children.get(id);
        if (!actorMessageSender) {
            return;
        }
        actorMessageSender.dispose();
    }
    send(entityId, message) {
        if (entityId == 0) {
            coreError('ActorLocationSenderComponent.send, entityId is 0');
            return;
        }
        let actorLocationSender = this.getOrCreate(entityId);
        let rpcId = ActorMessageSenderMgr.getInst().getRpcId();
        message.rpcId = rpcId;
        actorLocationSender.addReq(message);
        this.innerSend(entityId);
    }
    async innerSend(entityId) {
        let actorLocationSender = this.getOrCreate(entityId);
        if (actorLocationSender.isSending) {
            return;
        }
        try {
            let actorLocationSenderInstanceId = actorLocationSender.instanceId;
            actorLocationSender.isSending = true;
            let request = actorLocationSender.getReq();
            while (request) {
                if (actorLocationSender.instanceId != actorLocationSenderInstanceId) {
                    coreLog('ActorLocationSenderComponent.innerSend timeout, entityId={0}', entityId);
                    return;
                }
                // 队列中没处理的消息返回跟上个消息一样的报错
                if (actorLocationSender.Error == ErrorCore.ERR_NotFoundActor) {
                    coreLog('ActorLocationSenderComponent.sendCall ERR_NotFoundActor, entityId={0}, msg={1}', entityId, request.constructor.name);
                    return;
                }
                await this.callInner(actorLocationSender, request.rpcId, request);
                request = actorLocationSender.getReq();
            }
        }
        catch (e) {
            coreError('ActorLocationSenderComponent.innerSend error, entityId={0}, {2}', entityId, e.stack);
        }
        finally {
            actorLocationSender.isSending = false;
        }
    }
    async call(entityId, request) {
        if (entityId == 0) {
            coreError('ActorLocationSenderComponent.call, entityId is 0');
            return ActorHelper.createResponse(request, ErrorCore.ERR_ActorIdIsZero);
        }
        let actorLocationSender = this.getOrCreate(entityId);
        let rpcId = ActorMessageSenderMgr.getInst().getRpcId();
        request.rpcId = rpcId;
        let actorLocationSenderInstanceId = actorLocationSender.instanceId;
        // 用协程锁保证顺序
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.ActorLocationSender, entityId.toString());
        try {
            if (actorLocationSender.instanceId != actorLocationSenderInstanceId) {
                return ActorHelper.createResponse(request, ErrorCore.ERR_ActorLocationSenderDispose);
            }
            // 队列中没处理的消息返回跟上个消息一样的报错
            if (actorLocationSender.Error == ErrorCore.ERR_NotFoundActor) {
                coreLog(`ActorLocationSenderComponent.call ERR_NotFoundActor`);
                return ActorHelper.createResponse(request, actorLocationSender.Error);
            }
            let callResult = await this.callInner(actorLocationSender, rpcId, request);
            return callResult;
        }
        catch (e) {
            coreError('ActorLocationSenderComponent.call error, entityId={0}, msg={1}, {2}', entityId, request.constructor.name, e.stack);
            return ActorHelper.createResponse(request, ErrorCore.ERR_ActorLocationError);
        }
        finally {
            lock.dispose();
        }
    }
    async callInner(actorLocationSender, rpcId, iActorRequest) {
        let failTimes = 0;
        let instanceId = actorLocationSender.instanceId;
        actorLocationSender.LastSendOrRecvTime = TimeHelper.serverNow();
        while (true) {
            if (actorLocationSender.ActorId == 0) {
                actorLocationSender.ActorId = await LocationProxyComponent.inst.get(actorLocationSender.id);
                if (actorLocationSender.instanceId != instanceId) {
                    return ActorHelper.createResponse(iActorRequest, ErrorCore.ERR_ActorLocationSenderDispose);
                }
            }
            // 没有注册location 找不到很正常 不需要报错
            if (actorLocationSender.ActorId == 0) {
                actorLocationSender.Error = ErrorCore.ERR_NotFoundActor;
                return ActorHelper.createResponse(iActorRequest, ErrorCore.ERR_NotFoundActor);
            }
            let response = await ActorMessageSenderMgr.getInst().callWithRpcId(actorLocationSender.ActorId, rpcId, iActorRequest);
            if (actorLocationSender.instanceId != instanceId) {
                return ActorHelper.createResponse(iActorRequest, ErrorCore.ERR_ActorLocationSenderDispose);
            }
            switch (response.error) {
                case ErrorCore.ERR_NotFoundActor: {
                    // 如果没找到Actor,重试
                    ++failTimes;
                    if (failTimes > 5) {
                        coreLog(`actor send message fail, actorid: ${actorLocationSender.id}`);
                        actorLocationSender.Error = ErrorCore.ERR_NotFoundActor;
                        // 这里不能删除actor，要让后面等待发送的消息也返回ERR_NotFoundActor，直到超时删除
                        return response;
                    }
                    // 等待0.5s再发送
                    await TimerMgr.getInst().waitAsync(500);
                    if (actorLocationSender.instanceId != instanceId) {
                        return ActorHelper.createResponse(iActorRequest, ErrorCore.ERR_ActorLocationSenderDispose);
                    }
                    actorLocationSender.ActorId = 0;
                    continue;
                }
            }
            return response;
        }
    }
}

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * 客户端发给某个unit的消息
 */
let ActorLocationMessageHandler = class ActorLocationMessageHandler {
    run(session, msg) {
        let request = msg;
        // session还没有连接unit，没法发送消息给unit
        let unitId = GatePlayerHelper.getUnitIdFromSession(session);
        if (unitId == 0) {
            coreWarn(`unitId is 0, not send to unit`);
            return;
        }
        ActorLocationSenderComponent.inst.send(unitId, request);
    }
};
ActorLocationMessageHandler = __decorate$2([
    OuterMsgDecorator(MessageTypeCore.ActorLocationMessage)
], ActorLocationMessageHandler);

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * 这个是客户端直接发送给某个Unit的消息
 */
let ActorLocationReqMsgHandler = class ActorLocationReqMsgHandler {
    async run(session, msg) {
        let request = msg;
        // 这里可以优化 直接从session中获取unitId 不用再从gatePlayer中获取
        let unitId = GatePlayerHelper.getUnitIdFromSession(session);
        if (unitId == 0) {
            coreWarn('unitId is 0, not send to unit, msg={0}', msg.constructor.name);
            return;
        }
        let rpcId = request.rpcId; // 这里要保存客户端的rpcId
        let instanceId = session.instanceId;
        let iResponse = await ActorLocationSenderComponent.inst.call(unitId, request);
        iResponse.rpcId = rpcId;
        // session可能已经断开了，所以这里需要判断
        if (session.instanceId == instanceId) {
            session.Send(iResponse);
        }
    }
};
ActorLocationReqMsgHandler = __decorate$1([
    OuterMsgDecorator(MessageTypeCore.ActorLocationRequest)
], ActorLocationReqMsgHandler);

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let GeneralMsgHandler = class GeneralMsgHandler {
    run(session, msg) {
        MessageDispatcherMgr.getInst().handle(session, msg);
    }
};
GeneralMsgHandler = __decorate([
    OuterMsgDecorator(MessageTypeCore.Message),
    OuterMsgDecorator(MessageTypeCore.Request)
], GeneralMsgHandler);

const LOG = "info";
const WARN = "warn";
const ERROR = "error";
const customFormat = format.combine(format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }), format.align(), format.printf((i) => `${i.level}: ${[i.timestamp]}: ${i.message}`));
const defaultOptions = {
    format: customFormat,
    datePattern: "YYYY-MM-DD",
    zippedArchive: true,
    maxSize: "20m",
    maxFiles: "30d",
};
const logger = createLogger({
    format: customFormat,
    transports: [
        new DailyRotateFile({
            filename: "logs/info-%DATE%.log",
            level: LOG,
            ...defaultOptions,
        }),
        new DailyRotateFile({
            filename: "logs/error-%DATE%.log",
            level: ERROR,
            ...defaultOptions,
        }),
    ],
});
class WinstonLogger {
    log(str) {
        // 服务端开发阶段会输出到控制台
        if (Options.getInst().develop) {
            console.log(str);
        }
        logger.log(LOG, str);
    }
    warn(str) {
        // 服务端开发阶段会输出到控制台
        if (Options.getInst().develop) {
            console.warn(str);
        }
        logger.log(WARN, str);
    }
    error(str) {
        // 服务端开发阶段会输出到控制台
        if (Options.getInst().develop) {
            console.error(str);
        }
        logger.log(ERROR, str);
    }
}

class LoggerLoader {
    static run() {
        Game.addSingleton(Logger).iLog = new WinstonLogger;
        process.on('uncaughtException', function (err) {
            // 这里会导致进程结束
            coreError('[moye.uncaughtException][processid: {2}], message= {1}, stack= {0}', err.stack, err.message, Options.getInst().process);
        });
        process.on('unhandledRejection', function (reason, promise) {
            if (reason instanceof Error) {
                coreError('[moye.unhandledRejection], message= {1}, stack= {0}', reason.stack, reason.message);
            }
            else {
                coreError('[moye.unhandledRejection]', reason);
            }
        });
    }
}

/**
 * 解析命令行参数
 * 服务端才需要命令行 客户端不需要
 */
class OptionsLoader {
    static run() {
        Game.addSingleton(Options);
        let options = Options.getInst();
        let args = mri(process.argv.slice(2));
        for (const key in args) {
            let value = args[key];
            {
                if (value == null) {
                    console.error(`参数${key}没有值`);
                    continue;
                }
            }
            switch (typeof value) {
                case 'string':
                    if (value == 'true' || value == 'false') {
                        options._setArgs(key, (value == 'true'));
                        break;
                    }
                default:
                    options._setArgs(key, value);
                    break;
            }
        }
        if (options.getArgs('appType') != null) {
            options.appType = AppType[options.getArgs('appType')];
        }
        if (options.getArgs('logLevel') != null) {
            options.logLevel = options.getArgs('logLevel');
        }
        if (options.getArgs('develop') != null) {
            options.develop = options.getArgs('develop');
        }
        if (options.getArgs('process') != null) {
            options.process = options.getArgs('process');
        }
        options.isServer = true;
    }
}

/**
 * 用于守护进程启动其他进程
 */
class ProcessStartMgr extends Singleton {
    run() {
        let processMgr = ProcessMgr.getInst();
        let processInfos = processMgr.getThisMachineProcessInfos();
        let startArgsMap = new Map();
        let args = mri(process.argv.slice(2));
        // 将启动参数原样传递给其他进程
        for (const key in args) {
            let value = args[key];
            startArgsMap.set(key, value);
        }
        for (let processInfo of processInfos) {
            startArgsMap.set('appType', "Server");
            startArgsMap.set('process', processInfo.id);
            let newMap = new Map(startArgsMap);
            this.startProcess(newMap);
        }
    }
    startProcess(startArgsMap) {
        let entryScriptPath = process.argv[1];
        let processName = `process${startArgsMap.get('process')}`;
        // 这句应该可以process.argv获取到 后面再看
        let cmd = `node --es-module-specifier-resolution=node --no-warnings ${entryScriptPath}`;
        let cmds = [];
        for (let [key, value] of startArgsMap) {
            cmd += ` --${key}=${value}`;
            cmds.push(`--${key}=${value}`);
        }
        coreLog('启动子进程参数: {0}', cmd);
        let childProcess = fork(entryScriptPath, cmds);
        childProcess.disconnect();
        childProcess.on('error', (err) => {
            // This will be called with err being an AbortError if the controller aborts
            coreLog('子进程{0}错误: {1}: {2}', processName, err.message, err.stack);
            coreLog('重启子进程{0}', processName);
            return this.startProcess(startArgsMap);
        });
        childProcess.on('exit', (code, signal) => {
            coreLog('子进程{0}退出: code= {1}, signal= {2}', processName, code, signal);
            coreLog('重启子进程{0}', processName);
            return this.startProcess(startArgsMap);
        });
        childProcess.on('close', (code, signal) => {
            coreLog('子进程{0}关闭: code= {1}, signal= {2}', processName, code, signal);
            coreLog('重启子进程{0}', processName);
            return this.startProcess(startArgsMap);
        });
    }
}

class InitHelper {
    static checkInitStatus() {
        if (!MachineMgr.getInst().isInit()) {
            coreError(`MachineMgr没有初始化`);
            return false;
        }
        if (!ProcessMgr.getInst().isInit()) {
            coreError(`ProcessMgr没有初始化`);
            return false;
        }
        if (!this._checkScenes()) {
            return false;
        }
        return true;
    }
    /**
     * 检查一下是否包含了必须的scene
     */
    static _checkScenes() {
        if (!SceneMgr.getInst().isInit()) {
            coreError(`SceneMgr没有初始化`);
            return false;
        }
        let cfgs = SceneMgr.getInst().getSceneCfgs();
        let needSceneTypeCount = new Set;
        for (let i = 0; i < cfgs.length; i++) {
            let cfg = cfgs[i];
            if (this._needSceneTypes.has(cfg.sceneType)) {
                needSceneTypeCount.add(cfg.sceneType);
            }
        }
        if (needSceneTypeCount.size != this._needSceneTypes.size) {
            coreError(`SceneMgr初始化缺少必要的Scene`);
            return false;
        }
        return true;
    }
}
/**
 * 必不可少的scene
 */
InitHelper._needSceneTypes = new Set([
    SceneTypeCore.Realm,
    SceneTypeCore.Gate,
    SceneTypeCore.DBCache,
    SceneTypeCore.Location,
]);

/**
 * StartScene的父节点 其它的Scene也可以挂在这下面 看个人需求
 * StartScene: 启动的时候就创建的scene
 */
class SceneManagerComponent extends Entity {
    awake() {
        SceneManagerComponent.inst = this;
    }
    destroy() {
        SceneManagerComponent.inst = null;
    }
}

/**
 * 负责创建所有的scene
 */
class SceneCreator {
    static run() {
        let sceneInfos = SceneMgr.getInst().curProcessScenes();
        for (let i = 0; i < sceneInfos.length; i++) {
            let sceneInfo = sceneInfos[i];
            SceneFactory.createByInfo(SceneManagerComponent.inst, sceneInfo);
        }
    }
}

class Program {
    /**
     * 框架初始化 必须调用
     */
    static init() {
        coreLog('try program-init');
        OptionsLoader.run();
        LoggerLoader.run();
        Game.addSingleton(MachineMgr);
        Game.addSingleton(ProcessMgr);
        Game.addSingleton(SceneMgr);
        coreLog('program-init done');
    }
    /**
     * 确保所有脚本已经加载之后调用start
     */
    static async start() {
        if (!InitHelper.checkInitStatus()) {
            coreError(`初始化失败`);
            return;
        }
        Game.addSingleton(ObjectPool);
        MachineMgr.getInst().start();
        ProcessMgr.getInst().start();
        SceneMgr.getInst().start();
        // 守护进程的话 负责其他进程的启动就好了
        if (Options.getInst().appType == AppType.Watcher) {
            coreLog('Watcher 启动');
            Game.addSingleton(ProcessStartMgr).run();
            return;
        }
        coreLog('try program-start');
        this.addSingleton();
        this.addRootSceneCom();
        this.startTimer();
        // 发送入口事件
        await EventSystem.getInst().publishAsync(Root.getInst().scene, new EntryEvent());
        // 入口事件处理完就该创建scene了
        SceneCreator.run();
        // 忽略ping消息
        MsgPrinter.getInst().ignore(OuterMessageCoreOpcode.C2G_Ping);
        MsgPrinter.getInst().ignore(OuterMessageCoreOpcode.G2C_Ping);
        coreLog('program-start done');
    }
    /**
     * 启动update定时器
     */
    static startTimer() {
        setInterval(() => {
            try {
                this.update();
                this.lateUpdate();
            }
            catch (e) {
                coreError(e);
            }
        }, 1);
    }
    static update() {
        Game.update();
    }
    static lateUpdate() {
        Game.lateUpdate();
        Game.frameFinishUpdate();
    }
    static addSingleton() {
        Game.addSingleton(InvokeMgr);
        Game.addSingleton(EventSystem);
        Game.addSingleton(TimeInfo);
        Game.addSingleton(IdGenerator);
        Game.addSingleton(CoroutineLock);
        Game.addSingleton(TimerMgr);
        Game.addSingleton(MessageTypeMgr);
        Game.addSingleton(NetServices);
        Game.addSingleton(FlagMgr);
        Game.addSingleton(Root);
        Game.addSingleton(DBSerializeMgr);
        Game.addSingleton(ActorMessageSenderMgr);
        Game.addSingleton(LoginMgr);
        Game.addSingleton(FrameFinishActionMgr);
        Game.addSingleton(MessageParserMgr);
        Game.addSingleton(MsgPrinter);
        Game.addSingleton(OuterMessageMsgDispatcher);
        Game.addSingleton(InnerMessageDispatcher);
        Game.addSingleton(MessageDispatcherMgr);
        Game.addSingleton(ActorMessageDispatcherMgr);
        Game.addSingleton(ResponseTypeMgr);
        Game.addSingleton(ObjectSerializeMgr);
        Game.addSingleton(TaskQueueMgr);
    }
    static addRootSceneCom() {
        let rootScene = Root.getInst().scene;
        rootScene.addComponent(ActorLocationSenderComponent);
        rootScene.addComponent(NetInnerComponent);
        rootScene.addComponent(LocationProxyComponent);
    }
}

class ActorLocationMsgHelper {
    static async call(entityId, request, responseType) {
        let response = await ActorLocationSenderComponent.inst.call(entityId, request);
        return response;
    }
    static send(entityId, message) {
        ActorLocationSenderComponent.inst.send(entityId, message);
    }
}

/**
 * 断开与unit的连接
 */
class UnitDisconnectHelper {
    static async disconnect(unitId, sessionInstanceId, gateScene) {
        await this.sendDisconnectMsg(unitId, sessionInstanceId);
        EventSystem.getInst().publish(gateScene, AfterDisconnectUnit.create({ unitId: unitId }));
    }
    static async sendDisconnectMsg(unitId, sessionInstanceId) {
        coreLog(`[断开unit连接][G2M_DisconnectUnit start],unitid=${unitId}`);
        let response = await ActorLocationMsgHelper.call(unitId, new G2M_DisconnectUnit({
            sessionInstanceId: sessionInstanceId
        }), M2G_DisconnectUnit);
        coreLog(`[断开unit连接][G2M_DisconnectUnit end],unitid=${unitId}, error=${response.error}`);
        return response;
    }
}

class SessionDisconnectUnitCom extends Entity {
    init(sessionInstanceId, unitId) {
        this._sessionInstanceId = sessionInstanceId;
        this._unitId = unitId;
    }
    destroy() {
        UnitDisconnectHelper.disconnect(this._unitId, this._sessionInstanceId, this.domainScene());
    }
}

class UnitConnectHelper {
    /**
     * 连接unit
     * 如果unit在gatemap返回unit
     * @param session
     * @param unitId
     * @returns
     */
    static async connect(session, unitId) {
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.UnitConnect, unitId.toString());
        try {
            coreLog(`[连接unit][getUnitInstanceId start] unitId=${unitId}`);
            let unitInstanceId = await this.getUnitInstanceId(unitId);
            coreLog(`[连接unit][getUnitInstanceId end] unitId=${unitId} unitInstanceId=${unitInstanceId}`);
            let unit;
            // unit不在线 从数据库加载
            if (unitInstanceId == 0) {
                let [err, result] = await this.loadFromDB(session, unitId);
                if (err != ErrorCore.ERR_Success) {
                    return [err, null];
                }
                unit = result;
                if (session.isDisposed) {
                    unit.addComponent(UnitRefComponent).subRef();
                    return [ErrorCore.ERR_SessionDisposed, null];
                }
            }
            else {
                // unit在线 通知unit连接
                let sessionInstanceId = session.instanceId;
                coreLog(`[连接unit][发送G2M_ConnectUnit start] unitId=${unitId}`);
                let response = await ActorLocationMsgHelper.call(unitId, new G2M_ConnectUnit({
                    sessionInstanceId: sessionInstanceId
                }), M2G_ConnectUnit);
                // 连接不成功 上层可以再次尝试连接
                if (response.error != ErrorCore.ERR_Success) {
                    return [response.error, null];
                }
                coreLog(`[连接unit][发送G2M_ConnectUnit end] unitId=${unitId}, error=${response.error}`);
                // session销毁了 重新通知unit断开连接
                if (session.isDisposed) {
                    // unit应该做长时间不通信自动下线的机制
                    await UnitDisconnectHelper.sendDisconnectMsg(unitId, sessionInstanceId);
                    return [ErrorCore.ERR_SessionDisposed, null];
                }
                // // 连接不成功, 可能unit下线了, 再次从数据库加载
                // if (response.error != ErrorCore.ERR_Success) {
                //     let [err, ] = await this.loadFromDB(session, unitId);
                //     unit = await this.loadFromDB(session, unitId);
                //     if (session.isDisposed) {
                //         unit.addComponent(UnitRefComponent).subRef();
                //         return;
                //     }
                // } else {
                //     coreLog(`unit in map, dont need load from db unitId=${unitId}`);
                // }
            }
            /**
             * 连接完成后, 如果session断开, 通知unit断开连接
             */
            session.addComponent(SessionDisconnectUnitCom).init(session.instanceId, unitId);
            // 设置gatePlayer连接的unitId
            let gatePlayer = GatePlayerHelper.getGatePlayerFromSession(session);
            gatePlayer.getComponent(GatePlayerUnitComponent).unitId = unitId;
            EventSystem.getInst().publish(session.domainScene(), AfterConnectUnit.create({ unitId: unitId, session: session }));
            return [ErrorCore.ERR_Success, unit];
        }
        finally {
            lock.dispose();
        }
    }
    /**
     * 返回所在scene的instanceId
     * @param session
     * @param unitId
     * @returns
     */
    static async loadFromDB(session, unitId) {
        let [err, result] = await DBHelper.query(Unit, unitId);
        if (err != ErrorCore.ERR_Success) {
            return [err, null];
        }
        let unit = result;
        // 加载途中session断开了 直接抛弃这个unit
        if (session.isDisposed) {
            return [ErrorCore.ERR_SessionDisposed, null];
        }
        let gateMapCom = session.domainScene().getComponent(GateMapComponent);
        gateMapCom.addUnit(unit);
        // 注册位置服务
        await LocationProxyComponent.inst.add(unit.id, unit.instanceId);
        // 移除掉以前的actorLocationSender
        ActorLocationSenderComponent.inst.remove(unit.id);
        // 加载途中session断开了 移除掉这个unit
        if (session.isDisposed) {
            await LocationProxyComponent.inst.remove(unit.id);
            unit.dispose();
            return [ErrorCore.ERR_SessionDisposed, null];
        }
        unit.addComponent(UnitGateComponent).setSessionActorId(session.instanceId);
        unit.addComponent(MailBoxComponent);
        unit.addComponent(UnitRefComponent).addRef();
        return [ErrorCore.ERR_Success, unit];
    }
    static async getUnitInstanceId(unitId) {
        let instanceId = await LocationProxyComponent.inst.get(unitId);
        return instanceId;
    }
}

class GateMapHelper {
    static getGateMapInstanceId(session) {
        let gateMapCom = session.domainScene().getComponent(GateMapComponent);
        return gateMapCom.mapScene.instanceId;
    }
}

class TransferHelper {
    /**
     * 弃用
     * 当unit在gateMap的时候用这个传送
     * 在Map里面的话就不能用这个了
     * @param session
     * @param unitId
     * @param sceneInstanceId
     */
    // static transferBySession(session: Session, unitId: number, sceneInstanceId: number) {
    //     let gateMapCom = session.domainScene().getComponent(GateMapComponent);
    //     let unitCom = gateMapCom.getComponent(UnitComponent);
    //     let unit = unitCom.get(unitId);
    //     if (unit == null) {
    //         coreError("unit is null");
    //         return;
    //     }
    //     this.transfer(unit, sceneInstanceId);
    // }
    // /**
    //  * 不在gate上的时候 如果消息需要回应的话用这个
    //  * 等消息回应完了再传送 不然会找不到unit
    //  * 不要await这个函数
    //  * @param unit 
    //  * @param sceneInstanceId 
    //  */
    // static async transferAtFrameFinish(unit: Unit, sceneInstanceId: number){
    //     await Game.waitFrameFinish();
    //     await this.transfer(unit, sceneInstanceId);
    // }
    static async transfer(unit, sceneInstanceId) {
        if (unit.isDisposed) {
            return;
        }
        let lock = await CoroutineLock.getInst().wait(LockTypeCore.Transfer, unit.id.toString());
        try {
            if (unit.isDisposed) {
                return;
            }
            let time1;
            if (DEVELOP) {
                time1 = Date.now();
            }
            // location加锁
            let unitId = unit.id;
            let unitInstanceId = unit.instanceId;
            let request = new M2M_UnitTransferRequest();
            request.oldInstanceId = unitInstanceId;
            let isSameMachine = ProcessMgr.getInst().actorIdIsInMachine(sceneInstanceId);
            let serializeMgr = ObjectSerializeMgr.getInst();
            // request.unit = SerializeMgr.getInst().serializeToUint8Array(unit);
            if (isSameMachine) {
                request.unit = serializeMgr.serializeSameMachine(unit);
            }
            else {
                request.unit = serializeMgr.serialize(unit);
            }
            let flagMgr = FlagMgr.getInst();
            if (isSameMachine) {
                // 所有传送组件
                for (let [_, entity] of unit.components) {
                    if (flagMgr.hasFlag(DecoratorTypeCore.Transfer, entity.getType())) {
                        let bytes = serializeMgr.serializeSameMachine(entity);
                        request.entitys.push(bytes);
                    }
                }
            }
            else {
                for (let [_, entity] of unit.components) {
                    if (flagMgr.hasFlag(DecoratorTypeCore.Transfer, entity.getType())) {
                        let bytes = serializeMgr.serialize(entity);
                        request.entitys.push(bytes);
                    }
                }
            }
            if (DEVELOP) {
                let time2 = Date.now();
                let cost = time2 - time1;
                if (cost > 1) {
                    coreWarn(`transfer serialize cost time=${cost}ms, 请考虑优化!`);
                }
            }
            unit.dispose();
            coreLog(`unit开始传送, unitId=${unitId}`);
            await LocationProxyComponent.inst.lock(unitId, unitInstanceId);
            await ActorMsgHelper.call(sceneInstanceId, request);
        }
        finally {
            lock.dispose();
        }
    }
}

/**
 * 发送给unit的消息 且不用回复的用这个处理器
 * 这个会阻塞后续消息的处理 尽量不要在run里面await耗时操作
 * 如果有耗时操作 可以另外开一个协程
 */
class AMActorLocationHandler {
    handleSync(entity, fromProcess, message, responseType) {
        // 这里是为了告诉gate或其他scene这个消息已经收到了, 可以进行下一个消息的发送
        let response = new _ActorResponse({ rpcId: message.rpcId });
        ActorRequestHandleHelper.reply(fromProcess, response);
        {
            let ret = this.run(entity, message);
            if (ret instanceof Promise) {
                coreWarn('{0}.run 请不要使用异步, 因为异步没办法保证消息接收后的处理顺序, 如果需要可以另开一个协程处理', this.constructor.name);
                safeCall(ret);
            }
        }
    }
}

class UnitMsgHelper {
    /**
     * 发给客户端
     * @param unit
     * @param message
     */
    static sendToClient(unit, message) {
        let gateSessionActorId = unit.getComponent(UnitGateComponent).gateSessionActorId;
        // 与session断开了 就不用发了
        if (gateSessionActorId == 0) {
            return;
        }
        ActorMsgHelper.send(gateSessionActorId, message);
    }
    /**
     * 广播消息
     * @param mapScene
     * @param message
     */
    static broadcast(mapScene, message) {
        let unitComponent = mapScene.getComponent(UnitComponent);
        for (const [_, unit] of unitComponent.children) {
            this.sendToClient(unit, message);
        }
    }
    /**
     * 排除某个unitId的广播
     * @param mapScene
     * @param message
     * @param exceptUnitId
     */
    static broadcastExcept(mapScene, message, exceptUnitId) {
        let unitComponent = mapScene.getComponent(UnitComponent);
        for (const [_, unit] of unitComponent.children) {
            if (unit.id == exceptUnitId) {
                continue;
            }
            this.sendToClient(unit, message);
        }
    }
}

/**
 * 服务端不同进程之间的actor消息处理器
 * 不需要回应的消息用这个处理器
 */
class AMActorHandler {
    handleSync(entity, fromProcess, message, responseType) {
        {
            // let ret = ((): any => this.run(entity as Scene, message))();
            let ret = this.run(entity, message);
            if (ret instanceof Promise) {
                coreWarn('{0}.run 请不要使用异步, 因为异步没办法保证消息接收后的处理顺序, 如果需要可以另开一个协程处理', this.constructor.name);
                safeCall(ret);
            }
        }
    }
}

export { AEvent, AEventHandler, AInvoke, AInvokeHandler, AMActorHandler, AMActorLocationHandler, AMActorLocationRpcHandler, AMActorRpcHandler, AMHandler, AMRpcHandler, AWait, ActorLocationMsgHelper, ActorMessageHandlerDecorator, ActorMsgHelper, AfterConnectUnit, AfterCreateGatePlayer, AfterCreateUnit, AfterDisconnectUnit, AfterUnitTransfer, C2G_LoginGate, C2G_Ping, C2G_TestPressure, C2R_Login, CancellationToken, CoroutineLock, CoroutineLockItem, DB, DBHelper, DBWithKey, DecoratorCollector, DoubleMap, Entity, EntitySceneFactory, EntryEvent, EventComponent, EventHandlerDecorator, FrameFinishActionMgr, G2C_LoginGate, G2C_Ping, Game, GateMapHelper, GatePlayer, GatePlayerHelper, IPEndPoint, IdGenerator, IgnoreSerialize, Injector, InjectorDecorator, InnerMsgDecorator, InstanceIdHelper, InvokeDecorator, InvokeMgr, JsHelper, Logger, LoginMgr, MachineMgr, MessageDecorator, MessageDispatcherInfo, MessageDispatcherMgr, MessageHandlerDecorator, MessageParserDecorator, MessageParserMgr, MessageTypeCore, MessageTypeMgr, MsgPrinter, MultiMap, NetErrorEvent, NumericChange, NumericComponent, NumericWatcherHandlerDecorator, ObjectPool, ObjectSerializeMgr, ObjectWait, Options, OuterMsgDecorator, ProcessMgr, Program, R2C_Login, RandomGenerator, RecycleObj, ResponseTypeDecorator, Root, RpcInfo, Scene, SceneCreateEvent, SceneFactory, SceneMgr, SceneTypeCore, Session, Singleton, Task, TaskQueueMgr, TimeHelper, TimeInfo, TimerMgr, Transfer, TransferHelper, Unit, UnitComponent, UnitConnectHelper, UnitGateComponent, UnitMsgHelper, WaitError, error, log, warn };
